

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> modules/clients/ClientsModule.js</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    Documentation
                </a>
                
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Modules</h3><ul><li><a href="module-AboutModule.html">AboutModule</a></li><li><a href="module-AuthModule.html">AuthModule</a></li><li><a href="module-BackupModule.html">BackupModule</a></li><li><a href="module-ClientsModule.html">ClientsModule</a></li><li><a href="module-ConfigModule.html">ConfigModule</a></li><li><a href="module-DashboardModule.html">DashboardModule</a></li><li><a href="module-DataCache.html">DataCache</a></li><li><a href="module-ExportModule.html">ExportModule</a></li><li><a href="module-FECModule.html">FECModule</a></li><li><a href="module-FollowUpModule.html">FollowUpModule</a></li><li><a href="module-ImportModule.html">ImportModule</a></li><li><a href="module-InvoicesModule.html">InvoicesModule</a></li><li><a href="module-KeyboardShortcutsModule.html">KeyboardShortcutsModule</a></li><li><a href="module-Logger.html">Logger</a></li><li><a href="module-MLService.html">MLService</a></li><li><a href="module-MaterialsModule.html">MaterialsModule</a></li><li><a href="module-NotificationSystem.html">NotificationSystem</a></li><li><a href="module-NotificationSystemV2.html">NotificationSystemV2</a></li><li><a href="module-PDFModule.html">PDFModule</a></li><li><a href="module-QuickAddModule.html">QuickAddModule</a></li><li><a href="module-QuoteBuilderModule.html">QuoteBuilderModule</a></li><li><a href="module-QuotesModule.html">QuotesModule</a></li><li><a href="module-RevenueModule.html">RevenueModule</a></li><li><a href="module-ScannerModule.html">ScannerModule</a></li><li><a href="module-SuppliersModule.html">SuppliersModule</a></li><li><a href="module-TemplatesModule.html">TemplatesModule</a></li><li><a href="module-TourModule.html">TourModule</a></li><li><a href="module-UtilitiesModule.html">UtilitiesModule</a></li><li><a href="module-calculations.html">calculations</a></li><li><a href="module-constants.html">constants</a></li><li><a href="module-formatters.html">formatters</a></li><li><a href="module-helpers.html">helpers</a></li></ul><h3>Classes</h3><ul><li><a href="BaseModule.html">BaseModule</a></li><li><a href="BulkActionsManager.html">BulkActionsManager</a></li><li><a href="CacheKeys.html">CacheKeys</a></li><li><a href="EventBus.html">EventBus</a></li><li><a href="LoadingStateManager.html">LoadingStateManager</a></li><li><a href="ModalHelper.html">ModalHelper</a></li><li><a href="PaginationManager.html">PaginationManager</a></li><li><a href="ServerValidator.html">ServerValidator</a></li><li><a href="StateManager.html">StateManager</a></li><li><a href="TabRefreshManager.html">TabRefreshManager</a></li><li><a href="UndoRedoManager.html">UndoRedoManager</a></li><li><a href="module-AboutModule-AboutModule.html">AboutModule</a></li><li><a href="module-AuthModule-AuthModule.html">AuthModule</a></li><li><a href="module-BackupModule-BackupModule.html">BackupModule</a></li><li><a href="module-ClientsModule-ClientsModule.html">ClientsModule</a></li><li><a href="module-ConfigModule-ConfigModule.html">ConfigModule</a></li><li><a href="module-DashboardModule-DashboardModule.html">DashboardModule</a></li><li><a href="module-ExportModule-ExportModule.html">ExportModule</a></li><li><a href="module-FECModule-FECModule.html">FECModule</a></li><li><a href="module-ImportModule-ImportModule.html">ImportModule</a></li><li><a href="module-InvoicesModule-InvoicesModule.html">InvoicesModule</a></li><li><a href="module-Logger-Logger.html">Logger</a></li><li><a href="module-Logger-ModuleLogger.html">ModuleLogger</a></li><li><a href="module-MaterialsModule-MaterialsModule.html">MaterialsModule</a></li><li><a href="module-PDFModule-PDFModule.html">PDFModule</a></li><li><a href="module-QuickAddModule-QuickAddModule.html">QuickAddModule</a></li><li><a href="module-QuoteBuilderModule-QuoteBuilderModule.html">QuoteBuilderModule</a></li><li><a href="module-QuotesModule-QuotesModule.html">QuotesModule</a></li><li><a href="module-RevenueModule-RevenueModule.html">RevenueModule</a></li><li><a href="module-ScannerModule-ScannerModule.html">ScannerModule</a></li><li><a href="module-SuppliersModule-SuppliersModule.html">SuppliersModule</a></li><li><a href="module-TemplatesModule-TemplatesModule.html">TemplatesModule</a></li><li><a href="module-UtilitiesModule-UtilitiesModule.html">UtilitiesModule</a></li></ul><h3>Global</h3><ul><li><a href="global.html#clear">clear</a></li><li><a href="global.html#crypto">crypto</a></li><li><a href="global.html#emit">emit</a></li><li><a href="global.html#emitSync">emitSync</a></li><li><a href="global.html#off">off</a></li><li><a href="global.html#on">on</a></li><li><a href="global.html#once">once</a></li><li><a href="global.html#validateBeforeAddToQuote">validateBeforeAddToQuote</a></li><li><a href="global.html#validateBeforeExport">validateBeforeExport</a></li><li><a href="global.html#validateBeforeSaveMaterial">validateBeforeSaveMaterial</a></li><li><a href="global.html#validateBeforeSendEmail">validateBeforeSendEmail</a></li><li><a href="global.html#validateHeaderConfig">validateHeaderConfig</a></li><li><a href="global.html#validatePasswordChange">validatePasswordChange</a></li><li><a href="global.html#validateSMTPConfig">validateSMTPConfig</a></li><li><a href="global.html#waitFor">waitFor</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>modules/clients/ClientsModule.js</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * ========================================
 * CLIENTS MODULE - Gestion des clients
 * ========================================
 *
 * Module de gestion complÃ¨te des clients pour l'application AutoCalc OptiDevis.
 * GÃ¨re le catalogue de clients avec opÃ©rations CRUD, filtrage avancÃ© et liaison
 * avec les devis et factures.
 *
 * Architecture :
 * Le module gÃ¨re un catalogue de clients avec :
 * - **CRUD complet** : Create, Read, Update, Delete avec validation
 * - **Filtrage multi-critÃ¨res** : Recherche textuelle + filtre par type
 * - **Liaison devis/factures** : Affichage du nombre de devis et factures par client
 * - **Cache intelligent** : DataCache 5 minutes pour performance
 * - **Modals Bootstrap** : Formulaire d'ajout/Ã©dition + confirmation suppression
 *
 * ==========================================
 * DONNÃ‰ES CLIENT
 * ==========================================
 *
 * Structure d'un client (8 champs) :
 * - **id** : Identifiant unique (auto-incrÃ©mentÃ©)
 * - **name** : Nom du client (obligatoire, unique)
 * - **contact** : Nom du contact principal
 * - **email** : Adresse email du client
 * - **phone** : NumÃ©ro de tÃ©lÃ©phone
 * - **address** : Adresse complÃ¨te (tronquÃ©e Ã  50 caractÃ¨res dans tableau)
 * - **type** : Type de client (Particulier, Artisan, Entreprise gÃ©nÃ©rale, Promoteur)
 * - **siret** : NumÃ©ro SIRET (identifiant lÃ©gal)
 * - **notes** : Notes libres (tronquÃ©es Ã  30 caractÃ¨res dans tableau)
 *
 * Stockage : clients.json via IPC
 *
 * ==========================================
 * FONCTIONNALITÃ‰S CRUD
 * ==========================================
 *
 * **Create (Ajout)** :
 * 1. Utilisateur clique "Ajouter client"
 * 2. Modal s'ouvre avec formulaire vide
 * 3. Utilisateur remplit les champs (nom obligatoire)
 * 4. Validation : nom non vide
 * 5. Envoi via IPC 'addClient' avec authToken
 * 6. Invalidation cache + rechargement + rafraÃ®chissement tableau
 * 7. Notification succÃ¨s
 *
 * **Read (Lecture)** :
 * - Chargement au dÃ©marrage depuis cache ou backend (IPC 'get-clients')
 * - Affichage dans tableau triÃ© par ID
 * - Comptage des devis et factures par client (liaison avec catalog)
 * - Bouton "Voir devis et factures" pour basculer vers onglet Catalogue avec filtre actif
 *
 * **Update (Modification)** :
 * 1. Utilisateur clique icÃ´ne "Modifier" sur une ligne
 * 2. Modal s'ouvre avec formulaire prÃ©-rempli
 * 3. Utilisateur modifie les champs
 * 4. Validation : nom non vide
 * 5. Envoi via IPC 'updateClient' avec authToken + clientData.id
 * 6. Invalidation cache + rechargement + rafraÃ®chissement
 * 7. Notification succÃ¨s
 *
 * **Delete (Suppression)** :
 * 1. Utilisateur clique icÃ´ne "Supprimer"
 * 2. Modal de confirmation avec nom du client
 * 3. Confirmation utilisateur
 * 4. Envoi via IPC 'deleteClient' avec authToken + id
 * 5. Invalidation cache + rechargement + rafraÃ®chissement
 * 6. Fermeture modal + notification succÃ¨s
 *
 * ==========================================
 * FILTRAGE &amp; RECHERCHE
 * ==========================================
 *
 * **Recherche textuelle** (#search-clients) :
 * - Recherche dans : name, contact, email, phone
 * - Insensible Ã  la casse
 * - Temps rÃ©el (Ã©vÃ©nement 'input')
 *
 * **Filtre par type** (#filter-client-type) :
 * - Select gÃ©nÃ©rÃ© dynamiquement avec comptage par type
 * - Option "Tous les types" par dÃ©faut
 * - Format : "Type (nombre)"
 * - Ã‰vÃ©nement 'change'
 *
 * **Combinaison des filtres** :
 * - Les deux filtres se cumulent (ET logique)
 * - Notification du nombre de rÃ©sultats (toast 2s)
 * - Affichage "Aucun client trouvÃ©" si 0 rÃ©sultat
 *
 * ==========================================
 * LIAISON AVEC MATÃ‰RIAUX
 * ==========================================
 *
 * IntÃ©gration avec MaterialsModule :
 * - Comptage des devis et factures par client (material.client = client.name)
 * - Badge vert avec nombre si devis et factures > 0
 * - Bouton "Voir devis et factures" avec icÃ´ne Å“il
 * - Fonction viewClientQuotes() :
 *   1. Bascule vers onglet Catalogue (Bootstrap Tab API)
 *   2. Appelle filterByClientName() du MaterialsModule avec dÃ©lai 100ms
 *   3. Filtre automatiquement le catalogue par client
 *
 * UtilitÃ© : Permet de voir rapidement quels devis et factures viennent d'un client
 *
 * ==========================================
 * CACHE &amp; PERFORMANCE
 * ==========================================
 *
 * **DataCache avec TTL 5 minutes** :
 * - ClÃ© : 'clients'
 * - DurÃ©e : 5 * 60 * 1000 ms = 300 secondes
 * - VÃ©rification au loadClients() :
 *   - Si cache valide â†’ utilise cache
 *   - Si cache expirÃ© â†’ fetch backend + mise en cache
 * - Invalidation manuelle aprÃ¨s CRUD :
 *   - DataCache.invalidate('clients')
 *   - Force rechargement depuis backend
 *
 * **Synchronisation** :
 * - this.clients (instance)
 * - this.state.set('clients') (StateManager)
 * - window.clients (global, compatibilitÃ© legacy)
 * - DataCache ('clients')
 *
 * ==========================================
 * MODALS BOOTSTRAP
 * ==========================================
 *
 * **Modal Formulaire** (#clientFormModal) :
 * - Titre dynamique : "Ajouter" ou "Modifier"
 * - 11 champs de saisie
 * - Boutons : Sauvegarder, Annuler
 * - Focus automatique sur #client-name aprÃ¨s ouverture (dÃ©lai 500ms)
 * - Mode : this.editMode (boolean)
 *
 * **Modal Suppression** (#deleteClientModal) :
 * - Message dynamique avec nom du client
 * - Boutons : Confirmer, Annuler
 * - ID stockÃ© temporairement dans this.clientToDeleteId
 *
 * ==========================================
 * EVENT LISTENERS
 * ==========================================
 *
 * **Listeners globaux** (attachEventListeners) :
 * - Onglet #clients-tab â†’ shown.bs.tab : RafraÃ®chit tableau + attache listeners
 *
 * **Listeners spÃ©cifiques** (attachClientsListeners) :
 * - Protection contre double-attachement (clientsListenersAttached flag)
 * - Boutons : #add-client-btn, #save-client-btn, #cancel-client-btn, #confirmDeleteClientBtn
 * - Filtres : #search-clients (input), #filter-client-type (change)
 * - Tableau : onclick editClient(id), askDeleteClient(id), viewClientQuotes(name)
 *
 * ==========================================
 * Ã‰VÃ‰NEMENTS Ã‰MIS
 * ==========================================
 *
 * **EventBus interne** :
 * - 'initialized' : Au dÃ©marrage du module
 * - 'loaded' : AprÃ¨s chargement des clients (avec data)
 * - 'added' : AprÃ¨s ajout rÃ©ussi (avec clientData)
 * - 'updated' : AprÃ¨s modification rÃ©ussie (avec clientData)
 * - 'deleted' : AprÃ¨s suppression rÃ©ussie (avec id)
 *
 * **EventBus global** (this.events) :
 * - 'clients:loaded' : Pour notifier autres modules du chargement
 * - 'clients:updated' : AprÃ¨s tout changement (add/update/delete)
 *
 * UtilitÃ© : MaterialsModule peut Ã©couter 'clients:loaded' pour rafraÃ®chir son autocomplete
 *
 * ==========================================
 * INTÃ‰GRATIONS
 * ==========================================
 *
 * - **MaterialsModule** : Liaison par client name, fonction filterByClientName()
 * - **StateManager** : Stockage clients, editMode, clientToDeleteId
 * - **DataCache** : Cache 5 min pour performance
 * - **NotificationSystem** : Feedback utilisateur (success, error, info)
 * - **Bootstrap 5.3.3** : Modals, Tab API, Tooltips
 * - **IPC Electron** : get-clients, addClient, updateClient, deleteClient
 *
 * @module ClientsModule
 * @extends BaseModule
 * @version 2.0.0
 * @author AutoCalc OptiDevis
 */

import BaseModule from '../../core/BaseModule.js';
import NotificationSystem from '../../shared/ui/NotificationSystem.js';
import DataCache from '../../shared/ui/DataCache.js';
import ModalHelper from '../../shared/ui/ModalHelper.js';
import CacheKeys from '../../shared/cache/CacheKeys.js';
import BulkActionsManager from '../../shared/bulk/BulkActionsManager.js';
import { TextFormatter } from '../../shared/utils/formatters.js';

class ClientsModule extends BaseModule {
  /**
   * CrÃ©e une instance du module Clients.
   *
   * @param {StateManager} state - Gestionnaire d'Ã©tat global
   * @param {EventBus} eventBus - Bus d'Ã©vÃ©nements
   */
  constructor(state, eventBus) {
    super('clients', state, eventBus);

    /**
     * Cache local de tous les clients.
     * SynchronisÃ© avec StateManager et window.clients.
     *
     * @type {Array&lt;Object>}
     * @private
     */
    this.clients = [];

    /**
     * Liste filtrÃ©e des clients (aprÃ¨s recherche/filtre).
     * UtilisÃ© pour affichage conditionnel mais non actuellement exploitÃ©.
     *
     * @type {Array&lt;Object>}
     * @private
     */
    this.filteredClients = [];

    /**
     * Mode Ã©dition actif (true) ou ajout (false).
     *
     * @type {boolean}
     * @private
     */
    this.editMode = false;

    /**
     * ID du client Ã  supprimer (stockage temporaire pour modal).
     *
     * @type {number|null}
     * @private
     */
    this.clientToDeleteId = null;

    /**
     * Instance du modal Bootstrap de confirmation de suppression.
     *
     * @type {bootstrap.Modal|null}
     * @private
     */
    this.deleteModal = null;

    /**
     * Instance du modal Bootstrap du formulaire ajout/Ã©dition.
     *
     * @type {bootstrap.Modal|null}
     * @private
     */
    this.formModal = null;

    /**
     * Flag Ã©vitant le double-attachement des listeners.
     *
     * @type {boolean}
     * @private
     */
    this.clientsListenersAttached = false;

    /**
     * Configuration de pagination pour le tableau des clients.
     * @type {Object}
     * @private
     */
    this.pagination = {
      currentPage: 1,
      itemsPerPage: 25,
      totalItems: 0,
      totalPages: 0
    };

    /**
     * Gestionnaire d'actions groupÃ©es (bulk operations).
     *
     * @type {BulkActionsManager|null}
     * @private
     */
    this.bulkActions = null;
  }

  /**
   * Initialise le module Clients.
   * Charge les clients, peuple filtres et tableau, attache listeners, expose fonctions globales.
   *
   * @async
   * @returns {Promise&lt;void>}
   * @fires EventBus#initialized AprÃ¨s initialisation complÃ¨te
   */
  async init() {
    this.log('Initializing Clients Module...');
    console.log('ðŸšš ClientsModule v1.0 - Initialization');

    // Charger les clients depuis le backend
    await this.loadClients();

    // Populer les filtres et le tableau aprÃ¨s chargement
    this.populateTypeFilter();
    this.populateClientsTable();

    // Attacher les event listeners
    this.attachEventListeners();

    // Initialiser le gestionnaire d'actions groupÃ©es
    this.bulkActions = new BulkActionsManager({
      moduleName: 'clients',
      tableId: 'clients-table-body',
      checkboxClass: 'client-bulk-checkbox',
      selectAllId: 'clients-select-all',
      bulkActionsId: 'clients-bulk-actions',
      undoRedoManager: window.undoRedoManager,
      onDeleteCallback: this.bulkDeleteClients.bind(this),
      onExportCallback: this.bulkExportClients.bind(this)
    });
    this.bulkActions.initialize();

    // Exposer les fonctions au scope global (compatibilitÃ©)
    this.exposeToGlobal({
      loadClients: this.loadClients,
      populateClientsTable: this.populateClientsTable,
      addClient: this.addClient,
      saveClient: this.saveClient,
      editClient: this.editClient,
      deleteClient: this.deleteClient,
      askDeleteClient: this.askDeleteClient,
      clearClientForm: this.clearClientForm,
      applyClientFilters: this.applyClientFilters,
      populateTypeFilter: this.populateTypeFilter,
      viewClientQuotes: this.viewClientQuotes,
      viewClientDetails: this.viewClientDetails,
      changePage: this.changePage,
      goToPage: this.goToPage
    });

    // Exposer l'instance du module pour les mÃ©thodes de pagination
    window.clientsModule = this;

    // Initialiser le modal de suppression
    const deleteModalElement = this.getElement('#deleteClientModal');
    if (deleteModalElement &amp;&amp; typeof bootstrap !== 'undefined') {
      this.deleteModal = new bootstrap.Modal(deleteModalElement);
      this.log('Delete modal initialized');
    }

    // Initialiser le modal du formulaire
    const formModalElement = this.getElement('#clientFormModal');
    if (formModalElement &amp;&amp; typeof bootstrap !== 'undefined') {
      this.formModal = new bootstrap.Modal(formModalElement);
      this.log('Form modal initialized');
    }

    // Enregistrer l'auto-refresh de l'onglet
    this.registerTabRefresh();

    // ðŸ†• Enregistrer les commandes Command Palette (quand prÃªt)
    if (window.CommandPalette) {
      this.registerCommands();
    } else {
      // Attendre que Command Palette soit prÃªt
      this.events.on('commandpalette:ready', () => {
        this.registerCommands();
      });
    }

    this.log('Clients Module initialized successfully');
    this.emitEvent('initialized');
  }

  /**
   * ðŸ†• Enregistre l'onglet Clients pour auto-refresh automatique.
   *
   * @private
   * @returns {void}
   */
  registerTabRefresh() {
    if (!window.TabRefreshManager) {
      this.warn('TabRefreshManager not available - tab auto-refresh disabled');
      return;
    }

    // Onglet "Clients"
    window.TabRefreshManager.registerTab('clients-tab', async (force) => {
      this.log('ðŸ”„ Auto-refreshing Clients...');
      await this.loadClientsTab();
    }, {
      ttl: 30000, // 30 secondes
      label: 'Clients'
    });

    this.log('âœ… Tab auto-refresh registered');
  }

  /**
   * ðŸ†• Enregistre les commandes Command Palette pour le module Clients.
   *
   * @private
   */
  registerCommands() {
    if (!window.CommandPalette) return;

    // CrÃ©er client
    window.CommandPalette.registerCommand('clients-create', {
      label: 'ðŸ‘¤ CrÃ©er un nouveau client',
      keywords: ['crÃ©er', 'nouveau', 'client', 'customer', 'ajouter'],
      category: 'Clients',
      icon: 'ðŸ‘¤',
      priority: 15,
      condition: (ctx) => ctx.isAdmin === true, // ðŸ” Admin seulement
      action: async () => {
        document.getElementById('clients-tab')?.click();
        await new Promise(r => setTimeout(r, 150));
        window.addClient?.();
      }
    });

    // Voir clients
    window.CommandPalette.registerCommand('clients-list', {
      label: 'ðŸ‘¥ Voir tous les clients',
      keywords: ['clients', 'customers', 'liste', 'voir', 'tous'],
      category: 'Clients',
      icon: 'ðŸ‘¥',
      priority: 12,
      condition: (ctx) => ctx.isAdmin === true, // ðŸ” Admin seulement
      action: () => document.getElementById('clients-tab')?.click()
    });

    this.log('âœ… Command Palette commands registered');
  }

  /**
   * Charge les donnÃ©es de l'onglet Clients (alias pour loadClients).
   * UtilisÃ© par TabRefreshManager pour auto-refresh.
   *
   * @private
   * @async
   * @returns {Promise&lt;void>}
   */
  async loadClientsTab() {
    await this.loadClients();
    this.populateClientsTable();
  }

  /**
   * Attache les event listeners globaux du module.
   * Ã‰coute l'ouverture de l'onglet Clients pour rafraÃ®chir le tableau.
   *
   * @private
   * @returns {void}
   */
  attachEventListeners() {
    // Ã‰couter l'Ã©vÃ©nement d'ouverture de l'onglet Clients
    const clientsTab = this.getElement('#clients-tab');
    if (clientsTab) {
      clientsTab.addEventListener('shown.bs.tab', () => {
        // Clients tab shown - populating table
        this.attachClientsListeners();
        this.populateClientsTable();
      });
    }

    this.log('Event listeners attached');
  }

  /**
   * Attache les listeners spÃ©cifiques (boutons, filtres).
   * Protection contre double-attachement via flag.
   * @private
   */
  attachClientsListeners() {
    // Ne les attacher qu'une seule fois
    if (this.clientsListenersAttached) return;

    // Boutons de gestion des clients
    this.addDOMListener('#add-client-btn', 'click', () => {
      this.addClient();
    });

    this.addDOMListener('#export-clients-excel-btn', 'click', () => {
      this.exportClientsToExcel();
    });

    this.addDOMListener('#save-client-btn', 'click', () => {
      this.saveClient();
    });

    this.addDOMListener('#confirmDeleteClientBtn', 'click', () => {
      if (this.clientToDeleteId) {
        this.deleteClient(this.clientToDeleteId);
      }
    });

    this.addDOMListener('#cancel-client-btn', 'click', () => {
      this.clearClientForm();
    });

    // Filtres de recherche
    // Debouncing 300ms pour optimiser les performances de recherche
    const searchInput = this.getElement('#search-clients');
    if (searchInput) {
      let debounceTimer;
      searchInput.addEventListener('input', () => {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => {
          this.applyClientFilters();
        }, 300);
      });
    }

    const typeFilter = this.getElement('#filter-client-type');
    if (typeFilter) {
      typeFilter.addEventListener('change', () => {
        this.applyClientFilters();
      });
    }

    // Mise Ã  jour de l'aperÃ§u d'icÃ´ne pour le type de client
    this.addDOMListener('#client-type', 'change', (e) => {
      this.updateClientTypeIconPreview(e.target.value);
    });

    // Pagination - SÃ©lecteur items par page
    const itemsPerPageSelect = this.getElement('#clients-items-per-page');
    if (itemsPerPageSelect) {
      itemsPerPageSelect.addEventListener('change', (e) => {
        this.pagination.itemsPerPage = parseInt(e.target.value);
        this.pagination.currentPage = 1; // Reset to first page
        this.applyClientFilters();
      });
    }

    this.clientsListenersAttached = true;
    this.log('Clients listeners attached');
  }

  /**
   * Charge les clients depuis cache (5min) ou backend via IPC.
   * @public @async @fires EventBus#loaded @fires clients:loaded
   */
  async loadClients() {
    try {
      console.log('ðŸ”„ loadClients() called');

      // VÃ©rifier le cache
      const cached = DataCache.get('clients');
      if (cached &amp;&amp; cached.length > 0) {
        this.clients = cached;
        this.state.set('clients', cached);
        window.clients = cached;
        console.log(`âœ… Clients loaded from cache: ${cached.length} items`);
        this.emitEvent('loaded', this.clients);
        return;
      }

      // Charger depuis le backend
      console.log('ðŸŒ Calling backend API get-clients...');
      const response = await this.invoke('get-clients');
      console.log('ðŸŒ Backend response:', response);

      const clients = Array.isArray(response)
        ? response
        : (response.data || response.clients || []);
      console.log(`ðŸŒ Parsed clients: ${clients.length} items`);

      this.clients = clients;
      this.state.set('clients', clients);
      window.clients = clients;

      // Mettre en cache
      if (clients.length > 0) {
        DataCache.set('clients', clients, 5 * 60 * 1000); // 5 min
      }

      console.log(`âœ… Loaded ${clients.length} clients from backend`);
      this.emitEvent('loaded', clients);

      // Ã‰mettre un Ã©vÃ©nement global pour que d'autres modules puissent rÃ©agir
      this.events.emit('clients:loaded', clients);

      // Populer les filtres
      this.populateTypeFilter();

    } catch (error) {
      console.error('âŒ Error loading clients:', error);
      this.error('Error loading clients:', error);
      NotificationSystem.error('Erreur lors du chargement des clients');
    }
  }

  /**
   * Retourne l'icÃ´ne Font Awesome appropriÃ©e pour le type de client.
   *
   * @private
   * @param {string} clientType - Type du client (ex: "Artisan", "Entreprise gÃ©nÃ©rale", "Promoteur")
   * @returns {string} Code HTML de l'icÃ´ne avec sa couleur
   *
   * @example
   * getClientTypeIcon("Artisan")
   * // â†’ "&lt;i class='fas fa-hammer text-warning'>&lt;/i>"
   */
  getClientTypeIcon(clientType) {
    const iconMap = {
      'Artisan': "&lt;i class='fas fa-hammer text-warning'>&lt;/i>",
      'Entreprise gÃ©nÃ©rale': "&lt;i class='fas fa-building text-primary'>&lt;/i>",
      'Entreprise': "&lt;i class='fas fa-building text-primary'>&lt;/i>",
      'Promoteur': "&lt;i class='fas fa-city text-success'>&lt;/i>",
      'Particulier': "&lt;i class='fas fa-user text-info'>&lt;/i>",
      'Architecte': "&lt;i class='fas fa-drafting-compass text-secondary'>&lt;/i>",
      'MaÃ®tre d\'ouvrage': "&lt;i class='fas fa-hard-hat text-danger'>&lt;/i>",
      'CollectivitÃ©': "&lt;i class='fas fa-landmark text-info'>&lt;/i>",
      'Industriel': "&lt;i class='fas fa-industry text-dark'>&lt;/i>",
      'CommerÃ§ant': "&lt;i class='fas fa-store text-primary'>&lt;/i>",
      'Autre': "&lt;i class='fas fa-question text-muted'>&lt;/i>"
    };

    return iconMap[clientType] || "&lt;i class='fas fa-users text-muted'>&lt;/i>";
  }

  /**
   * Met Ã  jour l'aperÃ§u de l'icÃ´ne dans le formulaire client en fonction du type sÃ©lectionnÃ©.
   *
   * @param {string} clientType - Type du client sÃ©lectionnÃ© dans le dropdown
   * @returns {void}
   */
  updateClientTypeIconPreview(clientType) {
    const iconPreview = this.getElement('#client-type-icon-preview');
    if (!iconPreview) return;

    const iconHTML = this.getClientTypeIcon(clientType);
    iconPreview.innerHTML = iconHTML;
  }

  /**
   * Compte le nombre de devis, factures et CA pour chaque client.
   * Charge les devis et factures depuis les modules respectifs et les groupe par nom de client.
   *
   * @private
   * @async
   * @returns {Promise&lt;Object>} Objet avec clientName comme clÃ© et { quotes, invoices, totalRevenue } comme valeur
   *
   * @example
   * // Retourne: { "SARL Dupont": { quotes: 5, invoices: 3, totalRevenue: 15240.50 }, "Artisan Bernard": { quotes: 2, invoices: 1, totalRevenue: 3500.00 } }
   */
  async countQuotesAndInvoicesPerClient() {
    const counts = {};

    try {
      // RÃ©cupÃ©rer les devis depuis l'IPC
      const quotesResult = await this.invoke('list-saved-quotes');
      if (quotesResult.success &amp;&amp; quotesResult.quotes) {
        quotesResult.quotes.forEach(quote => {
          // Le handler list-saved-quotes extrait directement clientName
          const clientName = quote.clientName;
          if (clientName) {
            // Utiliser le nom normalisÃ© comme clÃ©
            const normalizedName = clientName.toLowerCase().trim();

            if (!counts[normalizedName]) {
              counts[normalizedName] = { quotes: 0, invoices: 0, totalRevenue: 0 };
            }
            counts[normalizedName].quotes++;
          }
        });
      }

      // RÃ©cupÃ©rer les factures depuis l'IPC
      const invoicesResult = await this.invoke('list-invoices');
      if (invoicesResult.success &amp;&amp; invoicesResult.invoices) {
        invoicesResult.invoices.forEach(invoice => {
          // Les factures ont clientInfo complet
          const clientName = invoice.clientInfo?.name;
          if (clientName) {
            // Utiliser le nom normalisÃ© comme clÃ©
            const normalizedName = clientName.toLowerCase().trim();

            if (!counts[normalizedName]) {
              counts[normalizedName] = { quotes: 0, invoices: 0, totalRevenue: 0 };
            }
            counts[normalizedName].invoices++;

            // Ajouter au CA seulement si la facture est payÃ©e
            if (invoice.status === 'payÃ©e') {
              const totalTTC = invoice.totals?.totalTTC || 0;
              counts[normalizedName].totalRevenue += totalTTC;
            }
          }
        });
      }
    } catch (error) {
      this.error('Error counting quotes and invoices per client:', error);
    }

    return counts;
  }

  /**
   * Peuple le tableau avec clients (tous ou filtrÃ©s) avec pagination. Trie par ID, affiche comptage devis et factures.
   * @public @param {Array} [filteredClients] Liste filtrÃ©e optionnelle
   */
  async populateClientsTable(filteredClients = null) {
    // Populate clients table

    const clientsSource = window.clients || this.clients;
    const clientsToShow = filteredClients || clientsSource;
    const tbody = this.getElement('#clients-table-body');

    if (!tbody) {
      // tbody not found
      return;
    }

    if (clientsToShow.length === 0) {
      tbody.innerHTML = '&lt;tr>&lt;td colspan="7" class="text-center">Aucun client trouvÃ©&lt;/td>&lt;/tr>';
      this.updatePaginationControls(0, []);
      return;
    }

    // Trier les clients par ID
    const sortedClients = [...clientsToShow].sort((a, b) => {
      const idA = parseInt(a.id) || 0;
      const idB = parseInt(b.id) || 0;
      return idA - idB;
    });

    // Mettre Ã  jour les infos de pagination
    this.pagination.totalItems = sortedClients.length;
    this.pagination.totalPages = Math.ceil(sortedClients.length / this.pagination.itemsPerPage);

    // S'assurer que currentPage est dans les limites
    if (this.pagination.currentPage > this.pagination.totalPages) {
      this.pagination.currentPage = this.pagination.totalPages || 1;
    }

    // Calculer les indices de dÃ©but et fin pour la page actuelle
    const startIndex = (this.pagination.currentPage - 1) * this.pagination.itemsPerPage;
    const endIndex = startIndex + this.pagination.itemsPerPage;
    const paginatedClients = sortedClients.slice(startIndex, endIndex);

    // Compter les devis et factures par client
    const quotesAndInvoicesCounts = await this.countQuotesAndInvoicesPerClient();

    tbody.innerHTML = paginatedClients.map(client => {
      const name = TextFormatter.escapeHtml(client.name ?? '-');
      const phone = TextFormatter.escapeHtml(client.phone ?? '-');
      const email = TextFormatter.escapeHtml(client.email ?? '');
      const type = TextFormatter.escapeHtml(client.type ?? '-');

      // Formater la colonne Contact (TÃ©lÃ©phone + Email)
      // Note: phone et email sont dÃ©jÃ  Ã©chappÃ©s ci-dessus
      let contactDisplay = '';
      if (phone !== TextFormatter.escapeHtml('-')) {
        contactDisplay = `&lt;i class="fas fa-phone text-primary">&lt;/i> ${phone}`;
      }
      if (email) {
        if (contactDisplay) contactDisplay += '&lt;br>';
        contactDisplay += `&lt;i class="fas fa-envelope text-secondary">&lt;/i> &lt;small>${email}&lt;/small>`;
      }
      if (!contactDisplay) {
        contactDisplay = '&lt;span class="text-muted">-&lt;/span>';
      }

      // Nombre de devis et factures pour ce client (recherche insensible Ã  la casse)
      const normalizedClientName = client.name.toLowerCase().trim();
      const counts = quotesAndInvoicesCounts[normalizedClientName] || { quotes: 0, invoices: 0, totalRevenue: 0 };
      const totalCount = counts.quotes + counts.invoices;
      const escapedClientName = TextFormatter.escapeHtml(client.name).replace(/'/g, '&amp;#39;');
      const materialsDisplay = totalCount > 0
        ? `&lt;span class="badge bg-primary">${counts.quotes} devis&lt;/span>
           &lt;span class="badge bg-success ms-1">${counts.invoices} facture${counts.invoices > 1 ? 's' : ''}&lt;/span>
           &lt;button onclick="viewClientQuotes('${escapedClientName}')" class="btn btn-sm btn-outline-primary btn-icon ms-1" data-bs-toggle="tooltip" title="Voir les devis et factures">
             &lt;i class="fas fa-eye">&lt;/i>
           &lt;/button>`
        : '&lt;span class="text-muted">Aucun&lt;/span>';

      // CA total (factures payÃ©es)
      const revenueDisplay = counts.totalRevenue > 0
        ? `&lt;strong class="text-success">${counts.totalRevenue.toFixed(2)} â‚¬&lt;/strong>`
        : '&lt;span class="text-muted">0,00 â‚¬&lt;/span>';

      // IcÃ´ne et badge pour le type de client
      const typeIcon = this.getClientTypeIcon(type);
      const typeDisplay = type !== '-'
        ? `${typeIcon} &lt;span class="badge bg-info">${type}&lt;/span>`
        : '&lt;span class="text-muted">-&lt;/span>';

      return `
        &lt;tr>
          &lt;td class="text-center">
            &lt;input type="checkbox" class="client-bulk-checkbox form-check-input" data-id="${client.id}">
          &lt;/td>
          &lt;td>&lt;strong>${name}&lt;/strong>&lt;/td>
          &lt;td>${contactDisplay}&lt;/td>
          &lt;td>${typeDisplay}&lt;/td>
          &lt;td>${materialsDisplay}&lt;/td>
          &lt;td>${revenueDisplay}&lt;/td>
          &lt;td>
            &lt;div class="btn-icon-group">
              &lt;button onclick="viewClientDetails(${client.id})" class="btn btn-sm btn-info btn-icon" data-bs-toggle="tooltip" title="Voir dÃ©tails">
                &lt;i class="fas fa-info-circle">&lt;/i>
              &lt;/button>
              &lt;button onclick="editClient(${client.id})" class="btn btn-sm btn-primary btn-icon" data-bs-toggle="tooltip" title="Modifier">
                &lt;i class="fas fa-edit">&lt;/i>
              &lt;/button>
              &lt;button class="btn btn-sm btn-danger btn-icon" onclick="askDeleteClient(${client.id})" data-bs-toggle="tooltip" title="Supprimer">
                &lt;i class="fas fa-trash-alt">&lt;/i>
              &lt;/button>
            &lt;/div>
          &lt;/td>
        &lt;/tr>
      `;
    }).join('');

    // Table populated successfully
    this.log(`Populated table with ${paginatedClients.length}/${sortedClients.length} clients (page ${this.pagination.currentPage}/${this.pagination.totalPages})`);

    // Mettre Ã  jour les contrÃ´les de pagination
    this.updatePaginationControls(sortedClients.length, paginatedClients);

    // RÃ©initialiser les sÃ©lections bulk aprÃ¨s le peuplement du tableau
    if (this.bulkActions) {
      this.bulkActions.clearSelection();
      this.bulkActions.updateBulkActionsUI();
    }
  }

  /**
   * GÃ©nÃ¨re le select de filtre par type avec comptages.
   * @public
   */
  populateTypeFilter() {
    const typeFilter = this.getElement('#filter-client-type');
    if (!typeFilter) return;

    const clientsSource = window.clients || this.clients;

    // Compter les clients par type
    const typeCount = {};
    clientsSource.forEach(s => {
      const type = s.type || 'Non catÃ©gorisÃ©';
      typeCount[type] = (typeCount[type] || 0) + 1;
    });

    const types = Object.keys(typeCount).sort();

    typeFilter.innerHTML = '&lt;option value="">Tous les types&lt;/option>' +
      types.map(type => `&lt;option value="${type}">${type} (${typeCount[type]})&lt;/option>`).join('');
  }

  /**
   * Applique les filtres de recherche et de type sur les clients.
   * Combine recherche textuelle ET filtre par type (logique AND).
   * Affiche le nombre de rÃ©sultats via notification.
   *
   * Workflow :
   * 1. RÃ©cupÃ¨re la valeur de recherche textuelle (#search-clients)
   * 2. RÃ©cupÃ¨re le type sÃ©lectionnÃ© (#filter-client-type)
   * 3. Filtre les clients (matchesSearch AND matchesType)
   * 4. Appelle populateClientsTable() avec la liste filtrÃ©e
   * 5. Affiche notification info avec le nombre de rÃ©sultats (toast 2s)
   *
   * Champs recherchÃ©s :
   * - name, contact, email, phone (insensible Ã  la casse)
   *
   * @public
   * @returns {void}
   * @fires NotificationSystem#info Affiche le nombre de clients affichÃ©s
   *
   * @example
   * // Utilisateur tape "Martin" dans #search-clients
   * // â†’ Filtre tous les clients contenant "martin" (name/contact/email/phone)
   * // â†’ Affiche "3 client(s) affichÃ©(s)" pendant 2s
   *
   * @example
   * // Utilisateur sÃ©lectionne "MaÃ§onnerie" + tape "Martin"
   * // â†’ Filtre seulement les maÃ§ons nommÃ©s "Martin"
   * // â†’ Affiche "1 client(s) affichÃ©(s)"
   */
  applyClientFilters() {
    const searchText = this.getValue('#search-clients')?.toLowerCase() || '';
    const selectedType = this.getValue('#filter-client-type') || '';

    const clientsSource = window.clients || this.clients;
    const filtered = clientsSource.filter(client => {
      const matchesSearch = !searchText ||
        client.name?.toLowerCase().includes(searchText) ||
        client.contact?.toLowerCase().includes(searchText) ||
        client.email?.toLowerCase().includes(searchText) ||
        client.phone?.toLowerCase().includes(searchText);

      const matchesType = !selectedType || client.type === selectedType;

      return matchesSearch &amp;&amp; matchesType;
    });

    this.populateClientsTable(filtered);
    this.log(`Filtered: ${filtered.length}/${clientsSource.length} clients`);

    // Notification du rÃ©sultat du filtrage
    if (searchText || selectedType) {
      NotificationSystem.info(`${filtered.length} client(s) affichÃ©(s)`, 2000);
    }
  }

  /**
   * PrÃ©pare le formulaire modal pour ajouter un nouveau client.
   * RÃ©initialise le formulaire, change le titre en "Ajouter", et affiche le modal.
   *
   * Workflow :
   * 1. Appelle clearClientForm() pour vider tous les champs
   * 2. DÃ©sactive editMode (mode ajout)
   * 3. Synchronise StateManager ('clientEditMode' = false)
   * 4. Change le titre du modal en "Ajouter un client" avec icÃ´ne camion
   * 5. Affiche le modal Bootstrap (#clientFormModal)
   * 6. Focus automatique sur #client-name aprÃ¨s 500ms
   *
   * @public
   * @returns {void}
   *
   * @example
   * // Utilisateur clique sur bouton "Ajouter client"
   * addClient();
   * // â†’ Modal s'ouvre avec formulaire vide
   * // â†’ Titre: "Ajouter un client"
   * // â†’ Focus sur champ Nom
   */
  addClient() {
    this.clearClientForm();
    this.editMode = false;
    this.state.set('clientEditMode', false);

    // Changer le titre du modal
    const formTitle = this.getElement('#client-form-title');
    if (formTitle) {
      formTitle.innerHTML = '&lt;i class="fas fa-users">&lt;/i> Ajouter un client';
    }

    // Afficher le modal
    if (this.formModal) {
      ModalHelper.show('clientFormModal');
    }

    // Focus sur le premier champ
    setTimeout(() => {
      const nameInput = this.getElement('#client-form-name');
      if (nameInput) nameInput.focus();
    }, 500);

    this.log('Add client form opened');
  }

  /**
   * Charge un client existant dans le formulaire modal pour Ã©dition.
   * Recherche le client par ID, prÃ©-remplit le formulaire et affiche le modal.
   *
   * Workflow :
   * 1. Recherche le client dans window.clients ou this.clients par ID
   * 2. Si introuvable â†’ NotificationSystem.error + return
   * 3. Active editMode (mode modification)
   * 4. Synchronise StateManager ('clientEditMode' = true)
   * 5. Change le titre du modal en "Modifier le client" avec icÃ´ne edit
   * 6. PrÃ©-remplit tous les 11 champs du formulaire avec setValue()
   * 7. Affiche le modal Bootstrap (#clientFormModal)
   *
   * @public
   * @param {number|string} id - ID du client Ã  Ã©diter
   * @returns {void}
   * @fires NotificationSystem#error Si le client n'est pas trouvÃ©
   *
   * @example
   * // Utilisateur clique sur icÃ´ne "Modifier" du client ID=5
   * editClient(5);
   * // â†’ Modal s'ouvre avec formulaire prÃ©-rempli
   * // â†’ Titre: "Modifier le client"
   * // â†’ Tous les champs contiennent les donnÃ©es du client
   */
  editClient(id) {
    console.log('ðŸ” EDIT CLIENT CALLED - ID:', id);

    const clientsSource = window.clients || this.clients;
    const client = clientsSource?.find(s => String(s.id) === String(id));

    if (!client) {
      console.error('âŒ CLIENT NOT FOUND FOR ID:', id);
      NotificationSystem.error('Client introuvable');
      return;
    }

    this.editMode = true;
    this.state.set('clientEditMode', true);

    // Changer le titre du modal
    const formTitle = this.getElement('#client-form-title');
    if (formTitle) {
      formTitle.innerHTML = '&lt;i class="fas fa-edit">&lt;/i> Modifier le client';
    }

    // Remplir le formulaire
    console.log('ðŸ”§ Remplissage du formulaire avec:', client);
    this.setValue('#client-id', client.id);
    this.setValue('#client-form-name', client.name || '');
    this.setValue('#client-contact', client.contact || '');
    this.setValue('#client-form-email', client.email || '');
    this.setValue('#client-form-phone', client.phone || '');
    this.setValue('#client-form-address', client.address || '');
    this.setValue('#client-type', client.type || '');
    this.setValue('#client-siret', client.siret || '');
    this.setValue('#client-delivery-delay', client.deliveryDelay || '');
    this.setValue('#client-website', client.website || '');
    this.setValue('#client-notes', client.notes || '');

    // Mettre Ã  jour l'aperÃ§u de l'icÃ´ne du type
    this.updateClientTypeIconPreview(client.type || '');

    console.log('âœ… Formulaire rempli complÃ¨tement');

    // Afficher le modal
    if (this.formModal) {
      ModalHelper.show('clientFormModal');
    }

    this.log('Editing client:', client.name);
  }

  /**
   * Sauvegarde un client (ajout ou modification selon editMode).
   * Valide le formulaire, envoie via IPC, invalide le cache et rafraÃ®chit.
   *
   * Workflow :
   * 1. RÃ©cupÃ¨re les 10 champs du formulaire (via getValue())
   * 2. Validation : nom obligatoire (sinon error + return)
   * 3. RÃ©cupÃ¨re sessionToken pour authentification IPC
   * 4. Si editMode = true :
   *    - RÃ©cupÃ¨re l'ID du client (#client-id)
   *    - Appelle IPC 'updateClient' avec sessionToken + clientData
   *    - Ã‰met Ã©vÃ©nement 'updated' avec clientData
   * 5. Si editMode = false :
   *    - Appelle IPC 'addClient' avec sessionToken + clientData
   *    - Ã‰met Ã©vÃ©nement 'added' avec clientData
   * 6. Invalide le cache DataCache ('clients')
   * 7. Recharge les clients (loadClients)
   * 8. RafraÃ®chit le tableau (populateClientsTable)
   * 9. Ã‰met Ã©vÃ©nement global 'clients:updated' (EventBus)
   * 10. Nettoie le formulaire (clearClientForm)
   *
   * @public
   * @async
   * @returns {Promise&lt;void>}
   * @fires NotificationSystem#error Si nom manquant ou erreur IPC
   * @fires NotificationSystem#success Si sauvegarde rÃ©ussie
   * @fires EventBus#added AprÃ¨s ajout rÃ©ussi (avec clientData)
   * @fires EventBus#updated AprÃ¨s modification rÃ©ussie (avec clientData)
   * @fires clients:updated Ã‰vÃ©nement global pour notifier autres modules
   *
   * @example
   * // Utilisateur remplit le formulaire et clique "Sauvegarder" (mode ajout)
   * await saveClient();
   * // â†’ IPC 'addClient' appelÃ©
   * // â†’ Cache invalidÃ©
   * // â†’ Tableau rafraÃ®chi
   * // â†’ "Client ajoutÃ© avec succÃ¨s"
   *
   * @example
   * // Utilisateur modifie un client existant et clique "Sauvegarder"
   * await saveClient();
   * // â†’ IPC 'updateClient' appelÃ© avec clientData.id
   * // â†’ Cache invalidÃ©
   * // â†’ "Client modifiÃ© avec succÃ¨s"
   */
  async saveClient() {
    try {
      // RÃ©cupÃ©rer les valeurs du formulaire
      const clientData = {
        name: this.getValue('#client-form-name'),
        contact: this.getValue('#client-contact') || '',
        email: this.getValue('#client-form-email') || '',
        phone: this.getValue('#client-form-phone') || '',
        address: this.getValue('#client-form-address') || '',
        type: this.getValue('#client-type') || '',
        siret: this.getValue('#client-siret') || '',
        deliveryDelay: parseInt(this.getValue('#client-delivery-delay') || 0),
        website: this.getValue('#client-website') || '',
        notes: this.getValue('#client-notes') || ''
      };

      // Validation
      if (!clientData.name) {
        NotificationSystem.error('Le nom du client est requis');
        return;
      }

      const sessionToken = this.getSessionToken();

      if (this.editMode) {
        // Modification - nÃ©cessite mode admin
        if (!sessionToken) {
          NotificationSystem.error('âš ï¸ Mode Admin requis pour modifier des clients. Veuillez vous connecter.');
          this.clearClientForm();
          return;
        }

        const id = this.getValue('#client-id');
        clientData.id = id;

        // ðŸ”„ Sauvegarder l'ancien Ã©tat pour Undo/Redo
        const oldClient = this.clients.find(c => c.id == id);
        const oldClientCopy = oldClient ? { ...oldClient } : null;

        const result = await this.invokeAPI('updateClient', sessionToken, clientData);

        if (result.success) {
          NotificationSystem.success('Client modifiÃ© avec succÃ¨s');
          this.emitEvent('updated', clientData);

          // ðŸ”„ Enregistrer l'action Undo/Redo
          if (window.UndoRedoManager &amp;&amp; oldClientCopy) {
            window.UndoRedoManager.record({
              type: 'CLIENT_UPDATE',
              description: `Modification client "${clientData.name}"`,
              undo: async () => {
                await this.invokeAPI('updateClient', sessionToken, oldClientCopy);
                DataCache.invalidate('clients');
                await this.loadClients();
                this.populateClientsTable();
                this.events.emit('clients:updated');
              },
              redo: async () => {
                await this.invokeAPI('updateClient', sessionToken, clientData);
                DataCache.invalidate('clients');
                await this.loadClients();
                this.populateClientsTable();
                this.events.emit('clients:updated');
              }
            });
          }
        } else {
          throw new Error(result.message || 'Erreur lors de la modification');
        }
      } else {
        // Ajout - autorisÃ© pour tous (vendeurs et admin)
        const result = await this.invokeAPI('addClient', sessionToken, clientData);

        if (result.success) {
          NotificationSystem.success('Client ajoutÃ© avec succÃ¨s');
          this.emitEvent('added', clientData);

          // ðŸ”„ Enregistrer l'action Undo/Redo
          if (window.UndoRedoManager &amp;&amp; result.client) {
            const newClientId = result.client.id || result.id;
            window.UndoRedoManager.record({
              type: 'CLIENT_CREATE',
              description: `CrÃ©ation client "${clientData.name}"`,
              undo: async () => {
                await this.invokeAPI('deleteClient', sessionToken, newClientId);
                DataCache.invalidate('clients');
                await this.loadClients();
                this.populateClientsTable();
                this.events.emit('clients:updated');
              },
              redo: async () => {
                await this.invokeAPI('addClient', sessionToken, clientData);
                DataCache.invalidate('clients');
                await this.loadClients();
                this.populateClientsTable();
                this.events.emit('clients:updated');
              }
            });
          }
        } else {
          throw new Error(result.message || "Erreur lors de l'ajout");
        }
      }

      // Recharger les clients
      DataCache.invalidate('clients');
      await this.loadClients();

      // RafraÃ®chir la table
      this.populateClientsTable();

      // Ã‰mettre un Ã©vÃ©nement global pour que d'autres modules puissent rÃ©agir
      this.events.emit('clients:updated');

      // Nettoyer le formulaire
      this.clearClientForm();

    } catch (error) {
      this.error('Error saving client:', error);
      NotificationSystem.error(error.message || 'Erreur lors de la sauvegarde');
    }
  }

  /**
   * Affiche le modal de confirmation pour supprimer un client.
   * Recherche le client, stocke son ID, personnalise le message et affiche le modal.
   *
   * Workflow :
   * 1. Recherche le client dans window.clients ou this.clients par ID
   * 2. Si introuvable â†’ NotificationSystem.error + return
   * 3. Stocke l'ID dans this.clientToDeleteId (utilisÃ© par confirmDeleteClientBtn)
   * 4. Synchronise StateManager ('clientToDeleteId')
   * 5. Met Ã  jour le message du modal (#deleteClientMessage) :
   *    "ÃŠtes-vous sÃ»r de vouloir supprimer "[nom]" ?"
   * 6. Affiche le modal Bootstrap (#deleteClientModal)
   *
   * @public
   * @param {number|string} id - ID du client Ã  supprimer
   * @returns {void}
   * @fires NotificationSystem#error Si le client n'est pas trouvÃ©
   *
   * @example
   * // Utilisateur clique sur icÃ´ne "Supprimer" du client ID=3
   * askDeleteClient(3);
   * // â†’ Modal de confirmation s'affiche
   * // â†’ Message: "ÃŠtes-vous sÃ»r de vouloir supprimer "BatiPro" ?"
   * // â†’ Bouton "Confirmer" â†’ appelle deleteClient(3)
   */
  askDeleteClient(id) {
    const clientsSource = window.clients || this.clients;
    const client = clientsSource.find(s => String(s.id) === String(id));

    if (!client) {
      NotificationSystem.error('Client introuvable');
      return;
    }

    this.clientToDeleteId = id;
    this.state.set('clientToDeleteId', id);

    // Mettre Ã  jour le message du modal
    const deleteMessage = this.getElement('#deleteClientMessage');
    if (deleteMessage) {
      deleteMessage.textContent = `ÃŠtes-vous sÃ»r de vouloir supprimer "${client.name}" ?`;
    }

    // Afficher le modal
    if (this.deleteModal) {
      ModalHelper.show('deleteClientModal');
    }

    this.log('Delete confirmation requested for:', client.name);
  }

  /**
   * Supprime dÃ©finitivement un client aprÃ¨s confirmation.
   * Envoie la requÃªte de suppression via IPC, invalide le cache et rafraÃ®chit.
   *
   * Workflow :
   * 1. Validation : ID non vide (sinon error + return)
   * 2. RÃ©cupÃ¨re sessionToken pour authentification IPC
   * 3. Appelle IPC 'deleteClient' avec sessionToken + id
   * 4. Si succÃ¨s :
   *    - Affiche NotificationSystem.success
   *    - Ã‰met Ã©vÃ©nement 'deleted' avec id
   *    - Ferme le modal de confirmation (#deleteClientModal)
   *    - Invalide cache DataCache ('clients')
   *    - Recharge les clients (loadClients)
   *    - RafraÃ®chit le tableau (populateClientsTable)
   *    - Ã‰met Ã©vÃ©nement global 'clients:updated' (EventBus)
   *    - RÃ©initialise this.clientToDeleteId
   * 5. Si erreur â†’ throw Error
   *
   * @public
   * @async
   * @param {number|string} id - ID du client Ã  supprimer
   * @returns {Promise&lt;void>}
   * @fires NotificationSystem#error Si ID invalide ou erreur IPC
   * @fires NotificationSystem#success Si suppression rÃ©ussie
   * @fires EventBus#deleted AprÃ¨s suppression rÃ©ussie (avec id)
   * @fires clients:updated Ã‰vÃ©nement global pour notifier autres modules
   *
   * @example
   * // Utilisateur confirme la suppression dans le modal
   * await deleteClient(3);
   * // â†’ IPC 'deleteClient' appelÃ©
   * // â†’ Cache invalidÃ©
   * // â†’ Tableau rafraÃ®chi
   * // â†’ Modal fermÃ©
   * // â†’ "Client supprimÃ© avec succÃ¨s"
   */
  async deleteClient(id) {
    try {
      if (!id) {
        this.error('deleteClient called with invalid ID:', id);
        NotificationSystem.error('Erreur: ID de client invalide');
        return;
      }

      // VÃ©rifier que l'utilisateur est en mode admin
      const sessionToken = this.getSessionToken();
      if (!sessionToken) {
        NotificationSystem.error('âš ï¸ Mode Admin requis pour supprimer des clients. Veuillez vous connecter.');
        if (this.deleteModal) {
          ModalHelper.hide('deleteClientModal');
        }
        return;
      }

      // ðŸ”„ Sauvegarder le client pour Undo/Redo
      const clientToDelete = this.clients.find(c => c.id == id);
      const clientCopy = clientToDelete ? { ...clientToDelete } : null;

      const result = await this.invokeAPI('deleteClient', sessionToken, id);

      if (result.success) {
        NotificationSystem.success('Client supprimÃ© avec succÃ¨s');
        this.emitEvent('deleted', id);

        // ðŸ”„ Enregistrer l'action Undo/Redo
        if (window.UndoRedoManager &amp;&amp; clientCopy) {
          window.UndoRedoManager.record({
            type: 'CLIENT_DELETE',
            description: `Suppression client "${clientCopy.name}"`,
            undo: async () => {
              await this.invokeAPI('addClient', sessionToken, clientCopy);
              DataCache.invalidate('clients');
              await this.loadClients();
              this.populateClientsTable();
              this.events.emit('clients:updated');
            },
            redo: async () => {
              await this.invokeAPI('deleteClient', sessionToken, id);
              CacheKeys.invalidate(CacheKeys.CLIENTS);
              await this.loadClients();
              this.populateClientsTable();
              this.events.emit('clients:updated');
            }
          });
        }

        // Fermer le modal
        if (this.deleteModal) {
          ModalHelper.hide('deleteClientModal');
        }

        // Recharger les clients
        CacheKeys.invalidate(CacheKeys.CLIENTS);
        await this.loadClients();

        // RafraÃ®chir la table
        this.populateClientsTable();

        // Ã‰mettre un Ã©vÃ©nement global pour que d'autres modules puissent rÃ©agir
        this.events.emit('clients:updated');

        this.clientToDeleteId = null;
      } else {
        throw new Error(result.message || 'Erreur lors de la suppression');
      }
    } catch (error) {
      this.error('Error deleting client:', error);
      NotificationSystem.error(error.message || 'Erreur lors de la suppression');
    }
  }

  /**
   * Nettoie complÃ¨tement le formulaire client et ferme le modal.
   * RÃ©initialise tous les champs, dÃ©sactive editMode et restaure le titre par dÃ©faut.
   *
   * Workflow :
   * 1. Vide les 11 champs du formulaire via setValue('') :
   *    - client-id, name, contact, email, phone, address, type,
   *      siret, delivery-delay, website, notes
   * 2. DÃ©sactive editMode (mode ajout)
   * 3. Synchronise StateManager ('clientEditMode' = false)
   * 4. Ferme le modal Bootstrap (#clientFormModal)
   * 5. RÃ©initialise le titre du modal en "Ajouter un client"
   *
   * AppelÃ© par :
   * - addClient() : Pour prÃ©parer un formulaire vide
   * - saveClient() : AprÃ¨s sauvegarde rÃ©ussie
   * - Bouton "Annuler" du modal (#cancel-client-btn)
   *
   * @public
   * @returns {void}
   *
   * @example
   * // Utilisateur clique "Annuler" dans le modal
   * clearClientForm();
   * // â†’ Tous les champs vidÃ©s
   * // â†’ Modal fermÃ©
   * // â†’ Titre rÃ©initialisÃ©
   */
  clearClientForm() {
    this.setValue('#client-id', '');
    this.setValue('#client-form-name', '');
    this.setValue('#client-contact', '');
    this.setValue('#client-form-email', '');
    this.setValue('#client-form-phone', '');
    this.setValue('#client-form-address', '');
    this.setValue('#client-type', '');
    this.setValue('#client-siret', '');
    this.setValue('#client-delivery-delay', '');
    this.setValue('#client-website', '');
    this.setValue('#client-notes', '');

    // RÃ©initialiser l'aperÃ§u de l'icÃ´ne du type
    this.updateClientTypeIconPreview('');

    this.editMode = false;
    this.state.set('clientEditMode', false);

    // Fermer le modal
    if (this.formModal) {
      ModalHelper.hide('clientFormModal');
    }

    // RÃ©initialiser le titre
    const formTitle = this.getElement('#client-form-title');
    if (formTitle) {
      formTitle.innerHTML = '&lt;i class="fas fa-users">&lt;/i> Ajouter un client';
    }

    this.log('Client form cleared');
  }

  /**
   * Retourne la liste triÃ©e des noms de clients pour autocomplete.
   * UtilisÃ© par d'autres modules (ex: MaterialsModule) pour remplir les champs d'autocomplete.
   *
   * @public
   * @returns {Array&lt;string>} Liste des noms de clients triÃ©s alphabÃ©tiquement
   *
   * @example
   * // MaterialsModule veut afficher une liste d'autocomplete de clients
   * const clientNames = getClientNames();
   * // â†’ ["BatiPro", "ElecPlus", "MaÃ§onMax", "PlombiPro"]
   *
   * @example
   * // Utilisation dans un champ autocomplete
   * const names = getClientNames();
   * autocomplete(document.getElementById("client-input"), names);
   */
  getClientNames() {
    const clientsSource = window.clients || this.clients;
    return clientsSource.map(s => s.name).sort();
  }

  /**
   * Bascule vers l'onglet Catalogue et filtre les devis et factures par client.
   * Utilise Bootstrap Tab API pour changer d'onglet et appelle filterByClientName() du MaterialsModule.
   *
   * Workflow :
   * 1. RÃ©cupÃ¨re l'onglet #admin-tab (Catalogue)
   * 2. Active l'onglet via Bootstrap Tab API (new bootstrap.Tab().show())
   * 3. Attend 100ms pour laisser l'onglet se charger
   * 4. Appelle window.filterByClientName(clientName) du MaterialsModule
   * 5. Si fonction non disponible â†’ affiche warning dans console
   *
   * IntÃ©gration :
   * - AppelÃ© par le bouton "Voir devis et factures" dans le tableau des clients
   * - Affiche le badge vert avec nombre de devis et factures (ex: "12")
   * - NÃ©cessite que MaterialsModule expose filterByClientName() en global
   *
   * @public
   * @param {string} clientName - Nom du client dont on veut voir les devis et factures
   * @returns {void}
   *
   * @example
   * // Utilisateur clique sur "Voir devis et factures" pour le client "BatiPro"
   * viewClientQuotes("BatiPro");
   * // â†’ Bascule vers onglet Catalogue
   * // â†’ Filtre actif: client = "BatiPro"
   * // â†’ Affiche uniquement les 12 devis et factures fournis par BatiPro
   */
  viewClientQuotes(clientName) {
    this.log(`Viewing quotes and invoices for client: ${clientName}`);

    // Basculer vers l'onglet Devis
    const quotesTab = this.getElement('#quotes-tab');
    if (quotesTab) {
      const tabTrigger = new bootstrap.Tab(quotesTab);
      tabTrigger.show();
    }

    // Filtrer les devis par nom de client
    // avec un lÃ©ger dÃ©lai pour laisser l'onglet se charger
    setTimeout(() => {
      const searchInput = document.getElementById('quotes-search-input');
      if (searchInput) {
        searchInput.value = clientName;
        // DÃ©clencher l'Ã©vÃ©nement de recherche
        const event = new Event('input', { bubbles: true });
        searchInput.dispatchEvent(event);
      }
    }, 150);
  }

  /**
   * Affiche les dÃ©tails complets d'un client dans un modal.
   *
   * Workflow :
   * 1. Chercher le client par ID dans la liste
   * 2. Si non trouvÃ© : afficher erreur, arrÃªter
   * 3. Remplir tous les champs du modal de dÃ©tails
   * 4. Afficher le modal 'clientDetailsModal'
   *
   * @public
   * @param {number|string} id - ID du client
   * @returns {void}
   *
   * @example
   * // Utilisateur clique sur "Voir dÃ©tails" pour le client #3
   * viewClientDetails(3);
   * // â†’ Modal affichÃ© avec toutes les informations du client
   */
  viewClientDetails(id) {
    this.log(`Viewing details for client ID: ${id}`);

    // Chercher le client
    const client = (window.clients || this.clients).find(s => String(s.id) === String(id));

    if (!client) {
      this.error('Client introuvable pour ID:', id);
      NotificationSystem.error('Client introuvable');
      return;
    }

    // Remplir tous les champs du modal
    this.setTextContent('#detail-client-id', client.id ?? '-');
    this.setTextContent('#detail-client-name', client.name ?? '-');
    this.setTextContent('#detail-client-contact', client.contact ?? '-');
    this.setTextContent('#detail-client-phone', client.phone ?? '-');
    this.setTextContent('#detail-client-email', client.email ?? '-');
    this.setTextContent('#detail-client-address', client.address ?? '-');
    this.setTextContent('#detail-client-type', client.type ?? '-');
    this.setTextContent('#detail-client-siret', client.siret ?? '-');
    this.setTextContent('#detail-client-delivery', client.deliveryDelay ? `${client.deliveryDelay} jours` : '-');
    this.setTextContent('#detail-client-website', client.website ?? '-');
    this.setTextContent('#detail-client-notes', client.notes ?? '-');

    // Afficher le modal
    ModalHelper.show('clientDetailsModal');
    this.log('Client details modal displayed for:', client.name);
  }

  /**
   * Exporte la liste des clients vers un fichier Excel.
   * GÃ©nÃ¨re un fichier Excel avec toutes les informations clients et leurs statistiques.
   *
   * @public
   * @async
   * @returns {Promise&lt;void>}
   *
   * @example
   * // Utilisateur clique sur "Exporter Excel"
   * await exportClientsToExcel();
   * // â†’ Fichier "clients-YYYY-MM-DD.xlsx" tÃ©lÃ©chargÃ©
   */
  async exportClientsToExcel() {
    try {
      this.log('Exporting clients to Excel...');

      // VÃ©rifier si XLSX est disponible
      if (typeof XLSX === 'undefined') {
        NotificationSystem.error('BibliothÃ¨que XLSX non disponible');
        return;
      }

      const clientsSource = window.clients || this.clients;
      if (!clientsSource || clientsSource.length === 0) {
        NotificationSystem.warning('Aucun client Ã  exporter');
        return;
      }

      // RÃ©cupÃ©rer les statistiques de devis/factures/CA
      const stats = await this.countQuotesAndInvoicesPerClient();

      // PrÃ©parer les donnÃ©es pour Excel
      const excelData = [
        ['Liste des Clients', '', '', '', '', '', ''],
        [`ExportÃ© le ${new Date().toLocaleDateString('fr-FR')} Ã  ${new Date().toLocaleTimeString('fr-FR')}`, '', '', '', '', '', ''],
        [],
        ['ID', 'Nom', 'Contact', 'Email', 'TÃ©lÃ©phone', 'Type', 'Nombre de Devis', 'Nombre de Factures', 'CA Total TTC (â‚¬)', 'SIRET', 'Adresse', 'Notes']
      ];

      // Ajouter chaque client
      clientsSource.forEach(client => {
        // Recherche insensible Ã  la casse
        const normalizedClientName = client.name.toLowerCase().trim();
        const clientStats = stats[normalizedClientName] || { quotes: 0, invoices: 0, totalRevenue: 0 };
        excelData.push([
          client.id || '',
          client.name || '',
          client.contact || '',
          client.email || '',
          client.phone || '',
          client.type || '',
          clientStats.quotes,
          clientStats.invoices,
          clientStats.totalRevenue.toFixed(2),
          client.siret || '',
          client.address || '',
          client.notes || ''
        ]);
      });

      // CrÃ©er le workbook et la feuille
      const ws = XLSX.utils.aoa_to_sheet(excelData);

      // DÃ©finir les largeurs de colonnes
      ws['!cols'] = [
        { wch: 5 },   // ID
        { wch: 30 },  // Nom
        { wch: 20 },  // Contact
        { wch: 30 },  // Email
        { wch: 15 },  // TÃ©lÃ©phone
        { wch: 20 },  // Type
        { wch: 12 },  // Devis
        { wch: 12 },  // Factures
        { wch: 15 },  // CA
        { wch: 18 },  // SIRET
        { wch: 40 },  // Adresse
        { wch: 40 }   // Notes
      ];

      // Mettre en gras les en-tÃªtes (ligne 4)
      const headerRow = 3; // Index 0-based
      for (let col = 0; col &lt; 12; col++) {
        const cellAddress = XLSX.utils.encode_cell({ r: headerRow, c: col });
        if (!ws[cellAddress]) continue;
        ws[cellAddress].s = {
          font: { bold: true },
          fill: { fgColor: { rgb: "4472C4" } },
          alignment: { horizontal: "center" }
        };
      }

      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, 'Clients');

      // GÃ©nÃ©rer le fichier en base64
      const wbout = XLSX.write(wb, { bookType: 'xlsx', type: 'base64' });

      // Sauvegarder avec l'API Electron
      const now = new Date();
      const filename = `clients-${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}.xlsx`;

      const saveResult = await this.invoke('save-excel', {
        base64: wbout,
        filename: filename,
        title: 'Exporter Liste Clients'
      });

      if (saveResult.success) {
        NotificationSystem.success(`Fichier Excel sauvegardÃ©: ${saveResult.path}`);
        this.log('Clients exported successfully:', saveResult.path);
      } else {
        NotificationSystem.warning(saveResult.message || 'Export annulÃ©');
      }

    } catch (error) {
      this.error('Error exporting clients to Excel:', error);
      NotificationSystem.error('Erreur lors de l\'export Excel');
    }
  }

  /**
   * DÃ©finit le contenu textuel d'un Ã©lÃ©ment (helper).
   * @private
   */
  setTextContent(selector, value) {
    const element = this.getElement(selector);
    if (element) {
      element.textContent = value;
    } else {
      this.warn(`Element not found: ${selector}`);
    }
  }

  /**
   * Change de page dans la pagination.
   * @param {number} direction - Direction: -1 pour prÃ©cÃ©dent, 1 pour suivant
   * @private
   */
  changePage(direction) {
    const newPage = this.pagination.currentPage + direction;
    if (newPage >= 1 &amp;&amp; newPage &lt;= this.pagination.totalPages) {
      this.pagination.currentPage = newPage;
      this.applyClientFilters();
    }
  }

  /**
   * Va Ã  une page spÃ©cifique.
   * @param {number} pageNumber - NumÃ©ro de page (1-indexed)
   * @private
   */
  goToPage(pageNumber) {
    if (pageNumber >= 1 &amp;&amp; pageNumber &lt;= this.pagination.totalPages) {
      this.pagination.currentPage = pageNumber;
      this.applyClientFilters();
    }
  }

  /**
   * Met Ã  jour les contrÃ´les de pagination (info et boutons).
   * @param {number} totalItems - Nombre total d'items
   * @param {Array} displayedItems - Items affichÃ©s sur la page actuelle
   * @private
   */
  updatePaginationControls(totalItems, displayedItems) {
    // Mettre Ã  jour l'info de pagination
    const paginationInfo = this.getElement('#clients-pagination-info');
    if (paginationInfo) {
      if (totalItems === 0) {
        paginationInfo.textContent = 'Aucun client';
      } else {
        const startIndex = (this.pagination.currentPage - 1) * this.pagination.itemsPerPage + 1;
        const endIndex = startIndex + displayedItems.length - 1;
        paginationInfo.textContent = `Affichage ${startIndex}-${endIndex} sur ${totalItems} clients`;
      }
    }

    // Mettre Ã  jour les boutons de pagination
    const paginationControls = this.getElement('#clients-pagination-controls');
    if (paginationControls &amp;&amp; totalItems > 0) {
      const prevDisabled = this.pagination.currentPage === 1 ? 'disabled' : '';
      const nextDisabled = this.pagination.currentPage === this.pagination.totalPages ? 'disabled' : '';

      // GÃ©nÃ©rer les numÃ©ros de page (max 5 pages visibles)
      const pageNumbers = this.generatePageNumbers();

      paginationControls.innerHTML = `
        &lt;button class="btn btn-sm btn-outline-primary" ${prevDisabled} onclick="window.clientsModule.changePage(-1)">
          &lt;i class="fas fa-chevron-left">&lt;/i> PrÃ©cÃ©dent
        &lt;/button>
        ${pageNumbers.map(page => {
          if (page === '...') {
            return '&lt;span class="mx-1">...&lt;/span>';
          }
          const active = page === this.pagination.currentPage ? 'btn-primary' : 'btn-outline-primary';
          return `&lt;button class="btn btn-sm ${active}" onclick="window.clientsModule.goToPage(${page})">${page}&lt;/button>`;
        }).join('')}
        &lt;button class="btn btn-sm btn-outline-primary" ${nextDisabled} onclick="window.clientsModule.changePage(1)">
          Suivant &lt;i class="fas fa-chevron-right">&lt;/i>
        &lt;/button>
      `;
    } else if (paginationControls) {
      paginationControls.innerHTML = '';
    }
  }

  /**
   * GÃ©nÃ¨re les numÃ©ros de page Ã  afficher (max 5 pages visibles avec ellipses).
   * @returns {Array} - Array de numÃ©ros de page et ellipses
   * @private
   */
  generatePageNumbers() {
    const pages = [];
    const total = this.pagination.totalPages;
    const current = this.pagination.currentPage;

    if (total &lt;= 7) {
      // Afficher toutes les pages si &lt;= 7
      for (let i = 1; i &lt;= total; i++) {
        pages.push(i);
      }
    } else {
      // Toujours afficher la premiÃ¨re page
      pages.push(1);

      if (current > 3) {
        pages.push('...');
      }

      // Pages autour de la page actuelle
      const start = Math.max(2, current - 1);
      const end = Math.min(total - 1, current + 1);

      for (let i = start; i &lt;= end; i++) {
        pages.push(i);
      }

      if (current &lt; total - 2) {
        pages.push('...');
      }

      // Toujours afficher la derniÃ¨re page
      pages.push(total);
    }

    return pages;
  }

  /**
   * Supprime plusieurs clients en une seule opÃ©ration (bulk delete).
   *
   * @async
   * @param {Array&lt;string|number>} clientIds - Liste des IDs de clients Ã  supprimer
   * @returns {Promise&lt;Object>} RÃ©sultat avec deletedItems, undoCallback, redoCallback
   */
  async bulkDeleteClients(clientIds) {
    try {
      this.log(`Bulk deleting ${clientIds.length} clients...`);

      // VÃ©rifier le mode admin
      const sessionToken = this.getSessionToken();
      if (!sessionToken) {
        NotificationSystem.error('Mode Admin requis pour supprimer des clients');
        throw new Error('Admin mode required');
      }

      // Sauvegarder les clients avant suppression (pour undo)
      const clientsToDelete = clientIds.map(id => {
        const client = this.clients.find(c => String(c.id) === String(id));
        return client ? { ...client } : null;
      }).filter(Boolean);

      // Supprimer tous les clients un par un
      const deletePromises = clientIds.map(id =>
        this.invokeAPI('deleteClient', sessionToken, id)
      );

      const results = await Promise.all(deletePromises);

      // VÃ©rifier si toutes les suppressions ont rÃ©ussi
      const allSuccess = results.every(r => r.success);
      if (!allSuccess) {
        const failedCount = results.filter(r => !r.success).length;
        throw new Error(`${failedCount} suppression(s) Ã©chouÃ©e(s)`);
      }

      // Recharger les clients
      CacheKeys.invalidate(CacheKeys.CLIENTS);
      await this.loadClients();
      this.populateClientsTable();
      this.events.emit('clients:updated');

      // PrÃ©parer les callbacks undo/redo
      const undoCallback = async () => {
        for (const client of clientsToDelete) {
          await this.invokeAPI('addClient', sessionToken, client);
        }
        CacheKeys.invalidate(CacheKeys.CLIENTS);
        await this.loadClients();
        this.populateClientsTable();
        this.events.emit('clients:updated');
      };

      const redoCallback = async () => {
        for (const id of clientIds) {
          await this.invokeAPI('deleteClient', sessionToken, id);
        }
        CacheKeys.invalidate(CacheKeys.CLIENTS);
        await this.loadClients();
        this.populateClientsTable();
        this.events.emit('clients:updated');
      };

      return {
        deletedItems: clientsToDelete,
        undoCallback,
        redoCallback
      };

    } catch (error) {
      this.error('Error in bulk delete clients:', error);
      NotificationSystem.error(error.message || 'Erreur lors de la suppression groupÃ©e');
      throw error;
    }
  }

  /**
   * Exporte plusieurs clients en CSV (bulk export).
   *
   * @async
   * @param {Array&lt;string|number>} clientIds - Liste des IDs de clients Ã  exporter
   * @returns {Promise&lt;void>}
   */
  async bulkExportClients(clientIds) {
    try {
      this.log(`Bulk exporting ${clientIds.length} clients...`);

      // RÃ©cupÃ©rer les clients sÃ©lectionnÃ©s
      const clientsToExport = clientIds.map(id => {
        const client = this.clients.find(c => String(c.id) === String(id));
        return client;
      }).filter(Boolean);

      if (clientsToExport.length === 0) {
        NotificationSystem.warning('Aucun client Ã  exporter');
        return;
      }

      // RÃ©cupÃ©rer les statistiques pour chaque client
      const stats = await this.countQuotesAndInvoicesPerClient();

      // Enrichir les clients avec les stats
      const enrichedClients = clientsToExport.map(client => {
        const normalizedName = client.name.toLowerCase().trim();
        const clientStats = stats[normalizedName] || { quotes: 0, invoices: 0, totalRevenue: 0 };
        return {
          ...client,
          quotesCount: clientStats.quotes,
          invoicesCount: clientStats.invoices,
          totalRevenue: clientStats.totalRevenue
        };
      });

      // GÃ©nÃ©rer le CSV
      const csv = this.generateCSV(enrichedClients);

      // Sauvegarder le fichier
      const now = new Date();
      const filename = `clients-export-${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}.csv`;

      const saveResult = await this.invoke('save-file', {
        content: csv,
        filename: filename,
        title: 'Exporter Clients SÃ©lectionnÃ©s',
        filters: [{ name: 'CSV', extensions: ['csv'] }]
      });

      if (saveResult.success) {
        NotificationSystem.success(`${clientsToExport.length} client(s) exportÃ©(s): ${saveResult.path}`);
        this.log('Clients exported successfully:', saveResult.path);
      } else {
        NotificationSystem.warning(saveResult.message || 'Export annulÃ©');
      }

    } catch (error) {
      this.error('Error in bulk export clients:', error);
      NotificationSystem.error('Erreur lors de l\'export groupÃ©');
    }
  }

  /**
   * GÃ©nÃ¨re un fichier CSV Ã  partir d'une liste de clients.
   *
   * @param {Array&lt;Object>} clients - Liste des clients Ã  exporter
   * @returns {string} Contenu CSV
   * @private
   */
  generateCSV(clients) {
    if (!clients || !Array.isArray(clients) || clients.length === 0) {
      return 'ID,Nom,Contact,Email,TÃ©lÃ©phone,Type,SIRET,Adresse,DÃ©lai de livraison,Site Web,Nombre de Devis,Nombre de Factures,CA Total TTC (â‚¬),Notes';
    }

    // En-tÃªtes CSV
    const headers = [
      'ID',
      'Nom',
      'Contact',
      'Email',
      'TÃ©lÃ©phone',
      'Type',
      'SIRET',
      'Adresse',
      'DÃ©lai de livraison',
      'Site Web',
      'Nombre de Devis',
      'Nombre de Factures',
      'CA Total TTC (â‚¬)',
      'Notes'
    ];

    // Fonction pour Ã©chapper les valeurs CSV
    const escapeCSV = (value) => {
      if (value == null) return '';
      const str = String(value);
      if (str.includes(',') || str.includes('"') || str.includes('\n')) {
        return `"${str.replace(/"/g, '""')}"`;
      }
      return str;
    };

    // Construire les lignes
    const rows = [headers.join(',')];

    clients.forEach(client => {
      const row = [
        escapeCSV(client.id),
        escapeCSV(client.name),
        escapeCSV(client.contact),
        escapeCSV(client.email),
        escapeCSV(client.phone),
        escapeCSV(client.type),
        escapeCSV(client.siret),
        escapeCSV(client.address),
        escapeCSV(client.deliveryDelay ? `${client.deliveryDelay} jours` : ''),
        escapeCSV(client.website),
        escapeCSV(client.quotesCount || 0),
        escapeCSV(client.invoicesCount || 0),
        escapeCSV(client.totalRevenue ? client.totalRevenue.toFixed(2) : '0.00'),
        escapeCSV(client.notes)
      ];
      rows.push(row.join(','));
    });

    return rows.join('\n');
  }
}

export default ClientsModule;
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.5</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>


</body>
</html>

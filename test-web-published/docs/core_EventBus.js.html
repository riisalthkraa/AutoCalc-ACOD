

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> core/EventBus.js</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    Documentation
                </a>
                
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Modules</h3><ul><li><a href="module-AboutModule.html">AboutModule</a></li><li><a href="module-AuthModule.html">AuthModule</a></li><li><a href="module-BackupModule.html">BackupModule</a></li><li><a href="module-ClientsModule.html">ClientsModule</a></li><li><a href="module-ConfigModule.html">ConfigModule</a></li><li><a href="module-DashboardModule.html">DashboardModule</a></li><li><a href="module-DataCache.html">DataCache</a></li><li><a href="module-ExportModule.html">ExportModule</a></li><li><a href="module-FECModule.html">FECModule</a></li><li><a href="module-FollowUpModule.html">FollowUpModule</a></li><li><a href="module-ImportModule.html">ImportModule</a></li><li><a href="module-InvoicesModule.html">InvoicesModule</a></li><li><a href="module-KeyboardShortcutsModule.html">KeyboardShortcutsModule</a></li><li><a href="module-Logger.html">Logger</a></li><li><a href="module-MLService.html">MLService</a></li><li><a href="module-MaterialsModule.html">MaterialsModule</a></li><li><a href="module-NotificationSystem.html">NotificationSystem</a></li><li><a href="module-NotificationSystemV2.html">NotificationSystemV2</a></li><li><a href="module-PDFModule.html">PDFModule</a></li><li><a href="module-QuickAddModule.html">QuickAddModule</a></li><li><a href="module-QuoteBuilderModule.html">QuoteBuilderModule</a></li><li><a href="module-QuotesModule.html">QuotesModule</a></li><li><a href="module-RevenueModule.html">RevenueModule</a></li><li><a href="module-ScannerModule.html">ScannerModule</a></li><li><a href="module-SuppliersModule.html">SuppliersModule</a></li><li><a href="module-TemplatesModule.html">TemplatesModule</a></li><li><a href="module-TourModule.html">TourModule</a></li><li><a href="module-UtilitiesModule.html">UtilitiesModule</a></li><li><a href="module-calculations.html">calculations</a></li><li><a href="module-constants.html">constants</a></li><li><a href="module-formatters.html">formatters</a></li><li><a href="module-helpers.html">helpers</a></li></ul><h3>Classes</h3><ul><li><a href="BaseModule.html">BaseModule</a></li><li><a href="BulkActionsManager.html">BulkActionsManager</a></li><li><a href="CacheKeys.html">CacheKeys</a></li><li><a href="EventBus.html">EventBus</a></li><li><a href="LoadingStateManager.html">LoadingStateManager</a></li><li><a href="ModalHelper.html">ModalHelper</a></li><li><a href="PaginationManager.html">PaginationManager</a></li><li><a href="ServerValidator.html">ServerValidator</a></li><li><a href="StateManager.html">StateManager</a></li><li><a href="TabRefreshManager.html">TabRefreshManager</a></li><li><a href="UndoRedoManager.html">UndoRedoManager</a></li><li><a href="module-AboutModule-AboutModule.html">AboutModule</a></li><li><a href="module-AuthModule-AuthModule.html">AuthModule</a></li><li><a href="module-BackupModule-BackupModule.html">BackupModule</a></li><li><a href="module-ClientsModule-ClientsModule.html">ClientsModule</a></li><li><a href="module-ConfigModule-ConfigModule.html">ConfigModule</a></li><li><a href="module-DashboardModule-DashboardModule.html">DashboardModule</a></li><li><a href="module-ExportModule-ExportModule.html">ExportModule</a></li><li><a href="module-FECModule-FECModule.html">FECModule</a></li><li><a href="module-ImportModule-ImportModule.html">ImportModule</a></li><li><a href="module-InvoicesModule-InvoicesModule.html">InvoicesModule</a></li><li><a href="module-Logger-Logger.html">Logger</a></li><li><a href="module-Logger-ModuleLogger.html">ModuleLogger</a></li><li><a href="module-MaterialsModule-MaterialsModule.html">MaterialsModule</a></li><li><a href="module-PDFModule-PDFModule.html">PDFModule</a></li><li><a href="module-QuickAddModule-QuickAddModule.html">QuickAddModule</a></li><li><a href="module-QuoteBuilderModule-QuoteBuilderModule.html">QuoteBuilderModule</a></li><li><a href="module-QuotesModule-QuotesModule.html">QuotesModule</a></li><li><a href="module-RevenueModule-RevenueModule.html">RevenueModule</a></li><li><a href="module-ScannerModule-ScannerModule.html">ScannerModule</a></li><li><a href="module-SuppliersModule-SuppliersModule.html">SuppliersModule</a></li><li><a href="module-TemplatesModule-TemplatesModule.html">TemplatesModule</a></li><li><a href="module-UtilitiesModule-UtilitiesModule.html">UtilitiesModule</a></li></ul><h3>Global</h3><ul><li><a href="global.html#clear">clear</a></li><li><a href="global.html#crypto">crypto</a></li><li><a href="global.html#emit">emit</a></li><li><a href="global.html#emitSync">emitSync</a></li><li><a href="global.html#off">off</a></li><li><a href="global.html#on">on</a></li><li><a href="global.html#once">once</a></li><li><a href="global.html#validateBeforeAddToQuote">validateBeforeAddToQuote</a></li><li><a href="global.html#validateBeforeExport">validateBeforeExport</a></li><li><a href="global.html#validateBeforeSaveMaterial">validateBeforeSaveMaterial</a></li><li><a href="global.html#validateBeforeSendEmail">validateBeforeSendEmail</a></li><li><a href="global.html#validateHeaderConfig">validateHeaderConfig</a></li><li><a href="global.html#validatePasswordChange">validatePasswordChange</a></li><li><a href="global.html#validateSMTPConfig">validateSMTPConfig</a></li><li><a href="global.html#waitFor">waitFor</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>core/EventBus.js</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * ========================================
 * EVENT BUS - Bus d'événements global
 * ========================================
 *
 * Système de communication inter-modules basé sur le pattern Publish/Subscribe (Observer).
 * Permet aux modules de communiquer sans couplage direct, favorisant une architecture
 * découplée et maintenable.
 *
 * Architecture :
 * - Pattern Publish/Subscribe (Pub/Sub) pour découplage maximal
 * - Système de priorités pour ordonner l'exécution des handlers
 * - Support des handlers "once" (exécutés une seule fois)
 * - Historique des événements pour le debugging
 * - Namespace pour organiser les événements par module
 * - Mode asynchrone (emit) et synchrone (emitSync)
 *
 * Responsabilités :
 * - Enregistrer des handlers (callbacks) pour des événements spécifiques
 * - Émettre des événements et notifier tous les handlers
 * - Gérer les priorités d'exécution des handlers
 * - Nettoyer automatiquement les handlers "once"
 * - Maintenir un historique des événements émis
 * - Fournir des statistiques sur l'utilisation du bus
 *
 * Conventions de nommage des événements :
 * Format: "module:action"
 * Exemples:
 * - materials:loaded - Matériaux chargés depuis la base
 * - materials:updated - Un matériau a été modifié
 * - materials:deleted - Un matériau a été supprimé
 * - quotes:saved - Un devis a été sauvegardé
 * - quotes:status-changed - Le statut d'un devis a changé
 * - auth:login - Connexion réussie
 * - auth:logout - Déconnexion
 * - invoices:paid - Une facture a été marquée comme payée
 *
 * Workflow typique :
 * ```javascript
 * // Module A - Émetteur (Materials)
 * class MaterialsModule {
 *   async loadMaterials() {
 *     const materials = await this.invoke('materials:get');
 *     this.events.emit('materials:loaded', materials);
 *   }
 * }
 *
 * // Module B - Récepteur (QuoteBuilder)
 * class QuoteBuilderModule {
 *   init() {
 *     this.events.on('materials:loaded', (materials) => {
 *       this.updateMaterialsList(materials);
 *     });
 *   }
 * }
 * ```
 *
 * Avantages du découplage :
 * - MaterialsModule ne connaît pas QuoteBuilderModule
 * - QuoteBuilderModule ne connaît pas MaterialsModule
 * - On peut ajouter/retirer des modules sans casser les autres
 * - Facilite les tests unitaires (mock de l'EventBus)
 *
 * Événements émis :
 * Aucun (l'EventBus est le mécanisme de communication, il n'émet pas lui-même)
 *
 * Événements écoutés :
 * Aucun (l'EventBus est passif, il relaye les événements entre modules)
 *
 * @module EventBus
 * @class EventBus
 * @version 1.0.0
 * @author Claude AI - AutoCalc OptiDevis Refactoring
 * @created 2024-10-XX
 */

class EventBus {
  /**
   * Constructeur de l'EventBus
   * Initialise les structures de données pour gérer les événements
   *
   * @constructor
   */
  constructor() {
    /**
     * Map des événements et leurs handlers
     * Structure: Map&lt;string, Array&lt;HandlerObject>>
     * HandlerObject: {handler: Function, priority: number, once: boolean, id: Symbol}
     * @type {Map&lt;string, Array>}
     * @private
     */
    this.events = new Map();

    /**
     * Historique des événements émis (pour debugging)
     * Chaque entrée contient: timestamp, event, data (si debug activé)
     * @type {Array&lt;Object>}
     * @private
     */
    this.eventHistory = [];

    /**
     * Taille maximale de l'historique (buffer circulaire FIFO)
     * @type {number}
     * @private
     */
    this.maxHistorySize = 100;

    /**
     * Mode debug : log tous les événements et handlers
     * @type {boolean}
     * @private
     */
    this.debug = false;

    /**
     * Cache des événements "once" déjà émis
     * Actuellement non utilisé mais prévu pour optimisation future
     * @type {Map}
     * @private
     */
    this.onceCache = new Map();
  }

  /**
   * Enregistre un handler pour un événement spécifique
   * Le handler sera appelé à chaque fois que l'événement est émis
   *
   * Système de priorités :
   * - Priorité 0 (défaut) : exécution normale
   * - Priorité > 0 : exécuté en premier (ordre décroissant)
   * - Priorité &lt; 0 : exécuté en dernier
   *
   * @param {string} event - Nom de l'événement (ex: 'materials:loaded')
   * @param {Function} handler - Fonction à appeler (signature: handler(data, event))
   * @param {Object} [options={}] - Options de configuration
   * @param {number} [options.priority=0] - Priorité d'exécution (plus haute = exécuté en premier)
   * @param {boolean} [options.once=false] - Si true, le handler est retiré après la première exécution
   * @returns {Function} Fonction de désinscription (à appeler pour arrêter d'écouter)
   *
   * @throws {Error} Si handler n'est pas une fonction
   *
   * @example
   * // Écouter un événement simple
   * const unsubscribe = eventBus.on('materials:loaded', (materials) => {
   *   console.log(`${materials.length} matériaux chargés`);
   *   updateUI(materials);
   * });
   *
   * // Plus tard, arrêter d'écouter
   * unsubscribe();
   *
   * @example
   * // Écouter avec priorité élevée (exécuté en premier)
   * eventBus.on('app:shutdown', () => {
   *   console.log('Sauvegarde critique avant fermeture');
   *   saveCriticalData();
   * }, { priority: 10 });
   *
   * eventBus.on('app:shutdown', () => {
   *   console.log('Nettoyage normal');
   * }, { priority: 0 }); // Exécuté après le handler prioritaire
   *
   * @example
   * // Handler "once" (exécuté une seule fois)
   * eventBus.on('app:first-load', () => {
   *   showWelcomeScreen();
   * }, { once: true });
   */
  on(event, handler, options = {}) {
    // Validation du type de handler
    if (typeof handler !== 'function') {
      throw new Error('[EventBus] Handler must be a function');
    }

    // Créer l'array de handlers pour cet événement si inexistant
    if (!this.events.has(event)) {
      this.events.set(event, []);
    }

    // Créer l'objet handler avec métadonnées
    const handlerObject = {
      handler,                          // La fonction callback
      priority: options.priority || 0,  // Priorité d'exécution
      once: options.once || false,      // Flag "once"
      id: Symbol('handler')             // ID unique pour désinscription
    };

    // Insérer le handler à la bonne position selon la priorité
    // Les handlers sont triés par priorité décroissante
    const handlers = this.events.get(event);
    const insertIndex = handlers.findIndex(h => h.priority &lt; handlerObject.priority);

    if (insertIndex === -1) {
      // Aucun handler de priorité inférieure, ajouter à la fin
      handlers.push(handlerObject);
    } else {
      // Insérer à la position appropriée
      handlers.splice(insertIndex, 0, handlerObject);
    }

    if (this.debug) {
      console.log(`[EventBus] Handler registered for: ${event} (priority: ${handlerObject.priority})`);
    }

    // Retourner une fonction de désinscription
    return () => this.off(event, handlerObject.id);
  }

  /**
   * Enregistre un handler qui sera exécuté une seule fois
   * Après la première exécution, le handler est automatiquement retiré
   *
   * Équivalent à : on(event, handler, { once: true })
   *
   * @param {string} event - Nom de l'événement
   * @param {Function} handler - Fonction à appeler
   * @returns {Function} Fonction de désinscription
   *
   * @example
   * // Écouter l'initialisation (une seule fois)
   * eventBus.once('app:initialized', () => {
   *   console.log('Application démarrée !');
   *   loadInitialData();
   * });
   *
   * @example
   * // Attendre que l'utilisateur se connecte
   * eventBus.once('auth:login', (user) => {
   *   showWelcomeMessage(user.name);
   * });
   */
  once(event, handler) {
    return this.on(event, handler, { once: true });
  }

  /**
   * Retire un handler d'un événement
   * Peut retirer par ID (Symbol) ou par référence de fonction
   *
   * @param {string} event - Nom de l'événement
   * @param {Symbol|Function} handlerOrId - ID du handler (Symbol) ou référence à la fonction
   *
   * @example
   * // Retirer via la fonction de désinscription (recommandé)
   * const unsubscribe = eventBus.on('materials:loaded', handleLoad);
   * unsubscribe();
   *
   * @example
   * // Retirer via la référence de fonction
   * const myHandler = (data) => console.log(data);
   * eventBus.on('test:event', myHandler);
   * // Plus tard...
   * eventBus.off('test:event', myHandler);
   */
  off(event, handlerOrId) {
    if (!this.events.has(event)) {
      return;
    }

    const handlers = this.events.get(event);

    // Filtrer les handlers pour retirer celui ciblé
    const filtered = handlers.filter(h => {
      if (typeof handlerOrId === 'symbol') {
        // Comparaison par ID (Symbol)
        return h.id !== handlerOrId;
      }
      // Comparaison par référence de fonction
      return h.handler !== handlerOrId;
    });

    // Si plus aucun handler, supprimer l'événement
    if (filtered.length === 0) {
      this.events.delete(event);
    } else {
      this.events.set(event, filtered);
    }

    if (this.debug) {
      console.log(`[EventBus] Handler removed for: ${event}`);
    }
  }

  /**
   * Émet un événement de manière asynchrone
   * Tous les handlers enregistrés sont appelés dans l'ordre de priorité
   *
   * Mode asynchrone :
   * - Les handlers sont exécutés avec await
   * - Les handlers peuvent retourner des Promises
   * - Les erreurs dans un handler n'empêchent pas les autres de s'exécuter
   *
   * Workflow :
   * 1. Ajoute l'événement à l'historique
   * 2. Log si mode debug
   * 3. Exécute tous les handlers dans l'ordre de priorité
   * 4. Gère les erreurs de chaque handler individuellement
   * 5. Retire les handlers "once" après exécution
   *
   * @param {string} event - Nom de l'événement (ex: 'materials:loaded')
   * @param {*} [data=null] - Données à passer aux handlers
   * @returns {Promise&lt;void>} Résout quand tous les handlers ont terminé
   *
   * @example
   * // Émettre un événement simple
   * await eventBus.emit('materials:loaded', materials);
   *
   * @example
   * // Émettre avec des données complexes
   * await eventBus.emit('quote:saved', {
   *   id: '12345',
   *   name: 'Devis Client ABC',
   *   total: 15000,
   *   items: [...]
   * });
   *
   * @example
   * // Les handlers asynchrones sont attendus
   * eventBus.on('data:save', async (data) => {
   *   await saveToDatabase(data);  // Opération async
   *   await syncToCloud(data);     // Opération async
   * });
   *
   * await eventBus.emit('data:save', myData); // Attend que tous les handlers finissent
   */
  async emit(event, data = null) {
    // Ajouter à l'historique pour le debugging
    this.addToHistory(event, data);

    if (this.debug) {
      console.log(`[EventBus] Event emitted: ${event}`, data);
    }

    // Si aucun handler enregistré, retourner immédiatement
    if (!this.events.has(event)) {
      return;
    }

    const handlers = this.events.get(event);
    const handlersToRemove = [];

    // Exécuter tous les handlers (déjà triés par priorité décroissante)
    for (const handlerObj of handlers) {
      try {
        // Appeler le handler avec les données et le nom de l'événement
        await handlerObj.handler(data, event);

        // Si handler "once", marquer pour suppression
        if (handlerObj.once) {
          handlersToRemove.push(handlerObj.id);
        }
      } catch (error) {
        // Isoler les erreurs : si un handler plante, continuer avec les autres
        console.error(`[EventBus] Error in handler for ${event}:`, error);
      }
    }

    // Retirer les handlers "once" après exécution
    handlersToRemove.forEach(id => this.off(event, id));
  }

  /**
   * Émet un événement de manière synchrone
   * Tous les handlers sont appelés immédiatement sans await
   *
   * ⚠️ Attention : Les handlers asynchrones ne seront PAS attendus
   * Utilisez emit() pour les handlers async
   *
   * @param {string} event - Nom de l'événement
   * @param {*} [data=null] - Données à passer aux handlers
   *
   * @example
   * // Émettre de manière synchrone (handlers synchrones uniquement)
   * eventBus.emitSync('ui:update', { tab: 'materials' });
   *
   * @example
   * // ⚠️ Mauvais usage : handler async non attendu
   * eventBus.on('data:save', async (data) => {
   *   await saveToDatabase(data); // ❌ Ne sera PAS attendu avec emitSync
   * });
   * eventBus.emitSync('data:save', data); // Continue immédiatement
   */
  emitSync(event, data = null) {
    this.addToHistory(event, data);

    if (this.debug) {
      console.log(`[EventBus] Event emitted (sync): ${event}`, data);
    }

    if (!this.events.has(event)) {
      return;
    }

    const handlers = this.events.get(event);
    const handlersToRemove = [];

    // Exécuter tous les handlers de manière synchrone
    handlers.forEach(handlerObj => {
      try {
        handlerObj.handler(data, event);

        if (handlerObj.once) {
          handlersToRemove.push(handlerObj.id);
        }
      } catch (error) {
        console.error(`[EventBus] Error in handler for ${event}:`, error);
      }
    });

    handlersToRemove.forEach(id => this.off(event, id));
  }

  /**
   * Attend qu'un événement spécifique soit émis
   * Retourne une Promise qui résout avec les données de l'événement
   *
   * Utile pour les workflows asynchrones où on attend un événement
   * avant de continuer
   *
   * @param {string} event - Nom de l'événement à attendre
   * @param {number|null} [timeout=null] - Timeout en millisecondes (optionnel)
   * @returns {Promise&lt;*>} Résout avec les données de l'événement
   * @throws {Error} Si timeout dépassé
   *
   * @example
   * // Attendre que les matériaux soient chargés
   * const materials = await eventBus.waitFor('materials:loaded');
   * console.log('Matériaux reçus:', materials);
   *
   * @example
   * // Attendre avec timeout de 5 secondes
   * try {
   *   const data = await eventBus.waitFor('api:response', 5000);
   *   processData(data);
   * } catch (error) {
   *   console.error('Timeout : API non répondu');
   * }
   *
   * @example
   * // Workflow : attendre la connexion avant de charger les données
   * async function loadUserData() {
   *   await eventBus.waitFor('auth:login');
   *   const userData = await fetchUserData();
   *   eventBus.emit('user:data-loaded', userData);
   * }
   */
  waitFor(event, timeout = null) {
    return new Promise((resolve, reject) => {
      let timeoutId = null;

      // Écouter l'événement une seule fois
      const unsubscribe = this.once(event, (data) => {
        if (timeoutId) clearTimeout(timeoutId);
        resolve(data);
      });

      // Configurer le timeout si spécifié
      if (timeout) {
        timeoutId = setTimeout(() => {
          unsubscribe();
          reject(new Error(`[EventBus] Timeout waiting for event: ${event}`));
        }, timeout);
      }
    });
  }

  /**
   * Retire tous les handlers d'un événement spécifique
   *
   * @param {string} event - Nom de l'événement à nettoyer
   *
   * @example
   * // Nettoyer tous les listeners d'un événement
   * eventBus.clear('materials:loaded');
   */
  clear(event) {
    this.events.delete(event);

    if (this.debug) {
      console.log(`[EventBus] All handlers cleared for: ${event}`);
    }
  }

  /**
   * Retire tous les handlers de tous les événements
   * Réinitialise complètement l'EventBus
   *
   * ⚠️ Attention : opération destructrice, utiliser avec précaution
   *
   * @example
   * // Réinitialiser complètement l'EventBus
   * eventBus.clearAll();
   */
  clearAll() {
    this.events.clear();
    this.eventHistory = [];

    if (this.debug) {
      console.log('[EventBus] All handlers cleared');
    }
  }

  /**
   * Ajoute un événement à l'historique pour le debugging
   * Utilise un buffer circulaire (FIFO) de taille maxHistorySize
   *
   * @param {string} event - Nom de l'événement
   * @param {*} data - Données de l'événement
   * @private
   */
  addToHistory(event, data) {
    this.eventHistory.push({
      timestamp: Date.now(),
      event,
      // Ne stocker les données qu'en mode debug (économie mémoire)
      data: this.debug ? data : null
    });

    // Limiter la taille de l'historique (buffer circulaire)
    if (this.eventHistory.length > this.maxHistorySize) {
      this.eventHistory.shift(); // Retirer le plus ancien
    }
  }

  /**
   * Récupère l'historique des événements émis
   * Utile pour le debugging et l'analyse de flux
   *
   * @param {number} [limit=20] - Nombre d'entrées à retourner (les plus récentes)
   * @returns {Array&lt;Object>} Historique des événements
   *                          Format: [{timestamp, event, data}, ...]
   *
   * @example
   * // Afficher les 10 derniers événements
   * const recent = eventBus.getHistory(10);
   * recent.forEach(entry => {
   *   console.log(`${new Date(entry.timestamp).toLocaleTimeString()} - ${entry.event}`);
   * });
   *
   * @example
   * // Tracer tous les événements "materials"
   * const materialEvents = eventBus.getHistory(100)
   *   .filter(e => e.event.startsWith('materials:'));
   */
  getHistory(limit = 20) {
    return this.eventHistory.slice(-limit);
  }

  /**
   * Obtient la liste de tous les événements enregistrés (ayant au moins un handler)
   *
   * @returns {Array&lt;string>} Liste des noms d'événements
   *
   * @example
   * // Lister tous les événements actifs
   * const events = eventBus.getEvents();
   * console.log('Événements actifs:', events);
   * // ['materials:loaded', 'quotes:saved', 'auth:login', ...]
   */
  getEvents() {
    return Array.from(this.events.keys());
  }

  /**
   * Obtient le nombre de handlers enregistrés pour un événement
   *
   * @param {string} event - Nom de l'événement
   * @returns {number} Nombre de handlers
   *
   * @example
   * // Vérifier combien de modules écoutent un événement
   * const count = eventBus.getHandlerCount('materials:loaded');
   * console.log(`${count} modules écoutent "materials:loaded"`);
   */
  getHandlerCount(event) {
    return this.events.has(event) ? this.events.get(event).length : 0;
  }

  /**
   * Obtient des statistiques complètes sur le bus d'événements
   * Utile pour le monitoring et l'optimisation
   *
   * @returns {Object} Statistiques
   * @returns {number} returns.totalEvents - Nombre total d'événements enregistrés
   * @returns {number} returns.totalHandlers - Nombre total de handlers
   * @returns {Object} returns.eventStats - Détail par événement: {event: handlerCount}
   *
   * @example
   * // Analyser l'utilisation du bus
   * const stats = eventBus.getStats();
   * console.log(`${stats.totalEvents} événements, ${stats.totalHandlers} handlers au total`);
   * console.table(stats.eventStats);
   *
   * @example
   * // Détecter les fuites de mémoire (trop de handlers)
   * const stats = eventBus.getStats();
   * Object.entries(stats.eventStats).forEach(([event, count]) => {
   *   if (count > 10) {
   *     console.warn(`⚠️ ${count} handlers pour "${event}" - possible fuite mémoire`);
   *   }
   * });
   */
  getStats() {
    const stats = {
      totalEvents: this.events.size,
      totalHandlers: 0,
      eventStats: {}
    };

    this.events.forEach((handlers, event) => {
      stats.totalHandlers += handlers.length;
      stats.eventStats[event] = handlers.length;
    });

    return stats;
  }

  /**
   * Active ou désactive le mode debug
   * En mode debug, tous les événements et handlers sont loggés
   * Les données des événements sont aussi stockées dans l'historique
   *
   * @param {boolean} enabled - true pour activer, false pour désactiver
   *
   * @example
   * // Activer le mode debug en développement
   * if (process.env.NODE_ENV === 'development') {
   *   eventBus.setDebug(true);
   * }
   */
  setDebug(enabled) {
    this.debug = enabled;
    console.log(`[EventBus] Mode debug: ${enabled ? 'ON' : 'OFF'}`);
  }

  /**
   * Crée un namespace pour organiser les événements par module
   * Préfixe automatiquement tous les événements avec le namespace
   *
   * Permet d'éviter les collisions de noms et d'organiser les événements
   * par module de manière cohérente
   *
   * @param {string} namespace - Préfixe à utiliser (ex: 'materials', 'quotes')
   * @returns {Object} API avec toutes les méthodes préfixées
   *
   * @example
   * // Dans MaterialsModule
   * class MaterialsModule extends BaseModule {
   *   constructor(state, events) {
   *     super('materials', state, events);
   *     // Créer un namespace automatiquement dans BaseModule
   *     this.moduleEvents = events.namespace('materials');
   *   }
   *
   *   async loadMaterials() {
   *     const materials = await this.invoke('materials:get');
   *     // Émet 'materials:loaded' automatiquement
   *     this.moduleEvents.emit('loaded', materials);
   *   }
   * }
   *
   * @example
   * // Dans un autre module qui écoute
   * class QuoteBuilderModule {
   *   init() {
   *     // Doit utiliser le nom complet pour écouter
   *     this.events.on('materials:loaded', (materials) => {
   *       this.updateList(materials);
   *     });
   *   }
   * }
   */
  namespace(namespace) {
    return {
      /**
       * Émet un événement avec namespace (async)
       * @param {string} event - Nom de l'événement (sans namespace)
       * @param {*} data - Données
       */
      emit: (event, data) => this.emit(`${namespace}:${event}`, data),

      /**
       * Émet un événement avec namespace (sync)
       * @param {string} event - Nom de l'événement (sans namespace)
       * @param {*} data - Données
       */
      emitSync: (event, data) => this.emitSync(`${namespace}:${event}`, data),

      /**
       * Écoute un événement avec namespace
       * @param {string} event - Nom de l'événement (sans namespace)
       * @param {Function} handler - Handler
       * @param {Object} options - Options
       */
      on: (event, handler, options) => this.on(`${namespace}:${event}`, handler, options),

      /**
       * Écoute un événement une fois avec namespace
       * @param {string} event - Nom de l'événement (sans namespace)
       * @param {Function} handler - Handler
       */
      once: (event, handler) => this.once(`${namespace}:${event}`, handler),

      /**
       * Retire un handler avec namespace
       * @param {string} event - Nom de l'événement (sans namespace)
       * @param {Function} handler - Handler
       */
      off: (event, handler) => this.off(`${namespace}:${event}`, handler),

      /**
       * Nettoie tous les handlers d'un événement avec namespace
       * @param {string} event - Nom de l'événement (sans namespace)
       */
      clear: (event) => this.clear(`${namespace}:${event}`),

      /**
       * Attend un événement avec namespace
       * @param {string} event - Nom de l'événement (sans namespace)
       * @param {number} timeout - Timeout en ms
       */
      waitFor: (event, timeout) => this.waitFor(`${namespace}:${event}`, timeout)
    };
  }
}

// Export pour utilisation en module ES6
export default EventBus;
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.5</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>


</body>
</html>
